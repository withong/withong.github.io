+++
title = "Redis (Remote Dictionary Server)"
date = "2025-05-29T22:49:01+09:00"
draft = false
tag = ["기술 면접", "Redis", "TIL"]
+++

<hr>
<br>

기존의 웹 애플리케이션은 데이터 저장에 **RDBMS(관계형 데이터베이스)** 를 주로 사용했다. 하지만 다음과 같은 한계가 있었다.

* 디스크 기반 저장 방식으로 인해 **읽기/쓰기 속도가 느림**
* 단순한 데이터를 처리하는 데에도 **복잡한 쿼리 구조와 I/O 병목**이 발생함
* 사용자 수가 급증할 경우, DB가 **병목 지점이 되어 전체 시스템 응답 지연**을 유발함
* 로그인 세션, 실시간 순위, 방문자 수 등 **즉각적인 반응이 필요한 기능**에 적합한 저장소가 부재함

이러한 문제를 해결하기 위해 등장한 것이 **메모리 기반의 Key-Value 저장소**이며, 그중 가장 널리 사용되는 기술이 Redis다.

<br>

## Redis란?

Redis는 **Remote Dictionary Server**의 약자로, 네트워크를 통해 접근 가능한 **사전(dictionary) 형태의 인메모리 데이터 저장소**이다. 데이터를 메모리에 저장하므로 **디스크 기반 저장소보다 훨씬 빠른 속도**를 제공하며, 다양한 자료구조와 부가 기능을 지원하여 단순한 캐시 서버 그 이상으로 활용된다.

<br>

## 핵심 특징

1. **인메모리 저장소**

   * 모든 데이터를 **RAM에 저장**하여 μs(마이크로초) 단위의 빠른 처리 속도를 제공함
   * 데이터를 디스크에 백업할 수 있지만, 기본 동작은 메모리 기반임
   * 설정된 정책에 따라 메모리 초과 시 **LRU(Least Recently Used)** 등 방식으로 데이터를 제거함

2. **다양한 자료구조**

   * Key-Value 형태 외에도 다음과 같은 구조를 지원함:

     * 문자열(String), 리스트(List), 집합(Set), 정렬된 집합(Sorted Set), 해시(Hash), 비트맵(Bitmap), 하이퍼로그로그(HyperLogLog), 스트림(Stream)
   * 이로 인해 단순 캐시뿐 아니라 **랭킹 시스템, 알림 큐, 채팅 메시지 관리 등 복합 로직**에 활용 가능함

3. **지속성(Persistence) 지원**

   * 메모리 기반임에도 **데이터 영속화를 위한 두 가지 방식** 제공:

     * **RDB (Snapshotting)**: 일정 주기로 전체 데이터를 디스크에 저장
     * **AOF (Append Only File)**: 모든 쓰기 연산을 로그로 저장
   * 둘을 조합해서 사용할 수도 있으며, AOF는 Redis 재시작 시 replay를 통해 데이터를 복구함
   * 단, 설정에 따라 **쓰기 직후 장애 발생 시 데이터 유실 가능성 존재** → 신중한 설정 필요

4. **고가용성 및 확장성**

   * **Replication**: 마스터-슬레이브 구조로 읽기 부하 분산
   * **Sentinel**: 마스터 장애 시 자동 장애 조치(Failover) 수행
   * **Cluster**: 데이터를 자동으로 분산 저장하고, 수평 확장 가능

5. **원자성 보장**

   * Redis의 단일 명령은 모두 원자적으로 수행됨
   * MULTI-EXEC 명령어를 사용하여 간단한 트랜잭션 구현 가능

6. **Pub/Sub 메시징 시스템**

   * 채널 기반의 **발행/구독(pub/sub)** 기능 제공
   * 실시간 채팅, 알림 서비스 등 메시지 브로커 용도로 사용 가능

<br>

## 구조와 동작 방식

Redis는 **단일 스레드 기반의 이벤트 루프 구조**로 동작한다. 일반적으로 병목으로 오해될 수 있지만, 메모리 접근이 매우 빠르고, 컨텍스트 스위칭이 없으며, 동기화 오버헤드가 없기 때문에 높은 처리량을 유지할 수 있다.

* 멀티 스레드보다 **단일 스레드가 더 빠른 상황**이 많음
* Redis 6부터는 **I/O 작업 일부에 한해 멀티 스레드 처리 가능**

<br>

## 사용 사례

* **세션 저장소**: 로그인 상태 저장 및 빠른 인증
* **캐시 저장소**: DB 부하를 줄이고 응답 속도 향상
* **순위 시스템**: Sorted Set을 이용한 실시간 랭킹
* **실시간 카운터**: 방문자 수, 좋아요 수 등 카운팅 기능
* **분산 락**: Redisson, Lettuce 등 클라이언트 라이브러리를 통한 락 구현
* **실시간 채팅 및 알림**: pub/sub 구조 활용

<br>

## 장점

* 메모리 기반으로 **매우 빠른 성능**
* 다양한 자료구조 지원으로 **활용 범위가 넓음**
* **간단한 설치와 운영**으로 도입이 쉬움
* 데이터 만료 기능(TTL) 지원
* 클러스터, 복제, Sentinel 등의 **확장성과 가용성 확보 기능**

<br>

## 단점

* 메모리에 저장되므로 **대용량 저장에는 비용 부담 큼**
* **기본은 단일 스레드**로 CPU 자원을 100% 활용하지 못함
* 잘못된 설정이나 장애 상황에서 **데이터 유실 가능성 있음**
* 복잡한 트랜잭션이나 조인 같은 연산은 지원하지 않음
* persistence 설정에 따라 **성능과 안정성 간의 트레이드오프** 존재

<br>

## 다른 기술과의 비교

| 항목      | Redis                   | Memcached             |
| ------- | ----------------------- | --------------------- |
| 자료구조    | String, List, Set 등 다양함 | 단순 Key-Value (String) |
| 지속성     | RDB, AOF 지원             | 비지속성                  |
| 복제/클러스터 | 지원함                     | 복제 미지원                |
| 스레드 모델  | 단일 스레드                  | 멀티 스레드                |
| TTL 지원  | 개별 Key마다 지원             | 전체 캐시에 일괄 설정됨         |
| 사용 범위   | 캐시, 세션, 실시간 처리 등 광범위    | 단순 캐시 목적에 한정됨         |

<br>

## Redis를 사용할 때 고려할 점

* **메모리 사용량**을 항상 모니터링해야 하며, eviction 정책 설정이 중요함
* persistence 설정에 따라 **성능과 데이터 안전성 간 균형**을 맞출 필요가 있음
* 다중 인스턴스를 운영할 경우 Sentinel이나 Cluster를 사용해 **장애 대응 구조를 구성**해야 함
* 락 처리 시에는 **Redisson, Lettuce 등 신뢰할 수 있는 라이브러리**를 사용하여 동시성 문제를 해결해야 함

<br>

Redis는 단순 캐시 이상의 기능을 제공하며, **실시간성, 처리 성능, 확장성**을 요구하는 다양한 백엔드 시스템에서 핵심 기술로 활용되고 있다. 특히 **JPA 기반 시스템에서 Redis를 캐시 계층으로 두거나, 분산 락 구현, 실시간 이벤트 처리** 등으로 통합하는 방식이 자주 등장한다.

<br>
<hr>