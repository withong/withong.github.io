+++
title = "Spring 심화 - JPA"
date = "2025-04-16T23:43:34+09:00"
draft = false
tag = ["내일배움캠프", "Spring", "JPA", "TIL"]
+++

<hr>
<br>

## 1. 연관관계 매핑

JPA는 객체 간의 연관관계를 데이터베이스의 외래 키로 매핑할 수 있도록 다음과 같은 어노테이션을 제공한다.

- `@ManyToOne`: 다대일 관계 (예: 여러 게시글이 하나의 작성자와 연결됨)
- `@OneToMany`: 일대다 관계 (예: 하나의 주문이 여러 상품과 연결됨)
- `@OneToOne`: 일대일 관계 (예: 한 사람당 하나의 여권을 가짐)
- `@ManyToMany`: 다대다 관계 (예: 여러 사용자가 여러 관심사를 가질 수 있음)

JPA에서 연관관계를 설계할 때는 반드시 외래 키(FK)를 어느 테이블이 관리할지 결정해야 하며, 이를 “연관관계의 주인”이라고 한다.  
실제 외래 키는 항상 "다수 쪽(N쪽)"에 존재하며, 해당 필드를 가진 객체가 연관관계의 주인이 되어야 한다.

<br>

## 2. 연관관계의 방향성

### 단방향
한 객체에서만 다른 객체를 참조하는 관계. 데이터베이스 입장에서 외래 키는 문제없지만, 객체 그래프 탐색은 제한된다.

### 양방향
양쪽 객체가 서로를 참조한다. 이 경우 JPA에서는 한쪽만 연관관계의 주인이 될 수 있고, 다른 쪽은 `mappedBy` 속성을 사용해 참조만 할 수 있다.

양방향 관계에서 연관관계의 주인이 아닌 쪽에서 값을 수정하면 실제 DB에 반영되지 않기 때문에, 항상 주인이 값을 관리해야 한다.

<br>

## 3. 1:N 관계 설계 시 유의사항

객체 관점에서 일대다(`@OneToMany`) 구조를 사용하면 자연스럽지만, 데이터베이스에서는 외래 키가 항상 다(N) 쪽에 있어야 하기 때문에 이 구조는 테이블 설계와 맞지 않는 구조가 된다.  

따라서, 실무에서는 다대일(`@ManyToOne`)을 사용해 외래 키를 직접 갖는 쪽이 연관관계의 주인이 되도록 설정하고, 일대다 관계는 `mappedBy`로 단순 조회용으로 유지하는 구조가 권장된다.

<br>

## 4. 1:1 연관관계

일대일 관계에서는 외래 키를 어느 쪽에 둘지 선택할 수 있다. 외래 키를 자신이 보유한 쪽이 연관관계의 주인이 된다.

- 외래 키를 자신이 가진 경우: 객체 지향적으로 자연스러우며, 조회가 간편하다.
- 외래 키를 상대가 가진 경우: 무결성 보장에 유리하지만 성능상 단점이 존재한다.

일대일 관계는 종종 일대다로 변경될 수 있는 가능성이 있으므로, 외래 키를 어떤 쪽이 갖는지 신중하게 결정해야 한다.

<br>

## 5. N:M 연관관계 (다대다)

객체에서는 다대다 관계를 직접 매핑할 수 있지만, 관계형 데이터베이스에서는 이를 직접 지원하지 않기 때문에 **중간 테이블**이 반드시 필요하다.

JPA에서 `@ManyToMany`를 사용하면 중간 테이블이 자동 생성되지만,  
이 구조는 다음과 같은 문제점을 가진다.

- 중간 테이블에 비즈니스적으로 중요한 컬럼(레벨, 상태 등)을 추가할 수 없다.
- 중간 테이블이 명시적으로 존재하지 않으므로 쿼리 분석이 어렵고 예측 불가능한 SQL이 실행된다.

실무에서는 중간 테이블을 별도 엔티티로 만들고, 다대일/일대다 관계로 풀어서 설계하는 것이 일반적이며 유연하고 확장 가능하다.

<br>

## 6. 상속관계 매핑

JPA는 객체의 상속 구조를 테이블에 매핑할 수 있도록 세 가지 전략을 제공한다.

### JOINED 전략
- 부모 테이블과 자식 테이블을 나누고, 조회 시 조인하여 데이터를 가져온다.
- 정규화가 가능하지만 성능 저하 가능성 있음

### SINGLE_TABLE 전략
- 하나의 테이블에 모든 자식 타입 데이터를 저장하고, DTYPE 컬럼으로 구분한다.
- 성능은 빠르지만 많은 null 컬럼이 발생하고 테이블이 비대해질 수 있음

### TABLE_PER_CLASS 전략
- 자식 클래스마다 별도 테이블을 만든다.
- 구조는 단순하나 조회 시 테이블 병합이 어렵고, 성능과 관리 측면에서 비효율적이다.

상속 관계가 실제 테이블 설계에서 필요한 경우는 드물며, 단순한 공통 필드만 공유하고 싶다면 `@MappedSuperclass`를 사용하는 것이 권장된다.

<br>

## 7. 프록시(Proxy)와 지연 로딩

JPA는 성능 최적화를 위해 프록시 객체를 사용한 **지연 로딩(Lazy Loading)**을 지원한다.

### 지연 로딩
- 연관된 객체를 실제 사용하는 시점에 SQL을 실행하여 데이터를 불러온다.
- `fetch = FetchType.LAZY` 설정 시 적용되며, 프록시 객체가 반환된다.
- 프록시는 실제 객체를 상속한 클래스이며, getter 호출 시 DB 조회가 수행된다.

### 즉시 로딩
- 연관 객체를 함께 즉시 로딩한다.
- `fetch = FetchType.EAGER`가 기본값인 경우도 있으나, 예기치 않은 쿼리 폭발을 유발할 수 있다.

실무에서는 모든 연관관계를 LAZY로 설정하고, 필요한 시점에 `fetch join`이나 `EntityGraph`를 사용하는 것이 일반적인 전략이다.

<br>

## 8. 영속성 전이 (Cascade)

영속성 전이는 특정 엔티티를 저장하거나 삭제할 때, 연관된 엔티티에도 동일한 작업을 자동으로 전파하는 기능이다.  
`cascade` 속성을 통해 전이 범위를 설정할 수 있다.

### 전이 종류
- `ALL`: 모든 전이 적용
- `PERSIST`: 저장 전이
- `REMOVE`: 삭제 전이
- `MERGE`, `REFRESH`, `DETACH` 등

연관된 엔티티가 부모에 완전히 종속적이고, 별도의 생명주기를 갖지 않는 경우에만 사용하는 것이 적절하다.  
예: 주문서와 그 안에 포함된 주문 상품 목록

<br>

## 9. 고아 객체 삭제

부모와 자식 엔티티 간의 연관관계가 끊어졌을 때,  
고아 객체가 자동으로 삭제되도록 설정할 수 있다.

- `orphanRemoval = true` 설정 시 적용
- 참조가 사라진 자식 객체는 DELETE 쿼리가 자동 실행된다
- `@OneToOne`, `@OneToMany`에서만 사용 가능하다

단, 고아 객체 삭제는 반드시 해당 자식 객체가 하나의 부모만 참조하고 있을 때에만 사용해야 하며, 생명주기가 완전히 일치하는 관계여야 한다.

<br>

## 10. 트랜잭션 전파 (Transaction Propagation)

트랜잭션 전파는 하나의 트랜잭션 내부에서 다른 트랜잭션이 호출될 때의 동작 방식을 정의한다.  
`@Transactional(propagation = ...)` 어노테이션을 통해 설정한다.

### 주요 Propagation 옵션

- `REQUIRED` (기본값): 기존 트랜잭션이 있으면 참여, 없으면 새로 시작
- `REQUIRES_NEW`: 항상 새로운 트랜잭션 생성, 기존 트랜잭션은 일시 중단
- `SUPPORTS`: 있으면 참여, 없으면 비트랜잭션으로 실행
- `NOT_SUPPORTED`: 트랜잭션이 있더라도 중단하고 트랜잭션 없이 실행
- `MANDATORY`: 반드시 트랜잭션이 있어야 실행 가능
- `NEVER`: 트랜잭션이 있으면 예외 발생
- `NESTED`: 중첩 트랜잭션 생성, 내부 롤백 가능

### 실무 예시

회원 가입 시 포인트 지급도 함께 이루어져야 하지만,  
포인트 지급에 실패하더라도 회원 가입은 롤백되지 않도록 하고 싶다면  
포인트 지급 메서드에 `REQUIRES_NEW` 전파 설정을 하면 된다.

<br>
<hr>

