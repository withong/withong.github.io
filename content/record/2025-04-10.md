+++
title = "JWT (JSON Web Token)"
date = "2025-04-10T20:22:48+09:00"
draft = false
tag = ["내일배움캠프", "과제", "일정 관리 API", "JWT", "TIL"]
+++

<hr>
<br>

## 1. JWT란?

**JWT (JSON Web Token)** 은 사용자 인증에 사용되는 **토큰 기반 인증 방식** 중 하나로,  
**서버에 상태를 저장하지 않고도 인증 정보를 유지할 수 있는 구조**다.

- **구조**
    ```
    헤더(header).페이로드(payload).서명(signature)
    ```
- **Base64로 인코딩**되며, **payload는 누구나 디코딩 가능**하므로 민감 정보를 넣지 않는다.
- **서명(Signature)** 으로 토큰의 위변조 여부를 서버가 확인할 수 있다.

- **주된 목적**: 정보의 위변조 방지 (정보 보호 아님)

<br>

## 2. 설정 방법
Spring Boot + JPA 프로젝트 기준  

**build.gradle**
```groovy
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'at.favre.lib:bcrypt:0.10.2'
    compileOnly 'org.projectlombok:lombok'
    runtimeOnly 'com.mysql:mysql-connector-j'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    // JWT 관련 추가
    implementation 'io.jsonwebtoken:jjwt-api:0.11.2'
    implementation 'io.jsonwebtoken:jjwt-impl:0.11.2'
    implementation 'io.jsonwebtoken:jjwt-jackson:0.11.2'
}
```
<br>

## 3. JWT 구조 및 인증 흐름

### JWT 구조

| 구성 요소 | 설명 |
|-----------|------|
| Header | 알고리즘 정보 (예: HS256) |
| Payload | 사용자 정보(예: username) 및 만료 시간 등 |
| Signature | secret key를 기반으로 만든 서명, 위변조 방지용 |

### JWT 인증 흐름

1. 클라이언트가 로그인 요청 (POST /login)
2. 서버가 사용자 인증 후 JWT 생성
3. 클라이언트는 JWT를 응답으로 받고, 저장 (쿠키, 로컬 스토리지 등)
4. 이후 요청마다 JWT를 Authorization 헤더에 담아 전송
5. 서버는 JWT 유효성 검사 (서명, 만료 여부 확인)
6. 인증 통과 시 사용자 정보 추출 후 요청 처리

<br>

## 4. 로그인 구현 예시

**User 엔티티**
```java
@Entity
public class User {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;
    private String password;
}
```

**UserRepository**
```java
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
}
```

**JwtUtil**
```java
public class JwtUtil {
    private static final String SECRET_KEY = "my-secret-key";
    private static final long EXPIRATION_TIME = 1000 * 60 * 60;

    public static String createToken(String username) {
        return Jwts.builder()
            .setSubject(username)
            .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
            .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
            .compact();
    }

    public static String getUsername(String token) {
        return Jwts.parser()
            .setSigningKey(SECRET_KEY)
            .parseClaimsJws(token)
            .getBody()
            .getSubject();
    }
}
```

**UserController**
```java
@RestController
public class UserController {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    public UserController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @PostMapping("/signup")
    public ResponseEntity<?> signup(@RequestBody User user) {
        if (userRepository.findByUsername(user.getUsername()).isPresent()) {
            return ResponseEntity.badRequest().body("이미 존재하는 사용자입니다.");
        }
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        userRepository.save(user);
        return ResponseEntity.ok("회원가입 완료");
    }

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody User user) {
        Optional<User> found = userRepository.findByUsername(user.getUsername());
        if (found.isEmpty()) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("존재하지 않는 사용자입니다.");
        }

        User realUser = found.get();
        if (!passwordEncoder.matches(user.getPassword(), realUser.getPassword())) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("비밀번호 불일치");
        }

        String token = JwtUtil.createToken(realUser.getUsername());
        return ResponseEntity.ok(Collections.singletonMap("token", token));
    }
}
```

<br>

## 5. 인증 구현 예시 (JWT 필터)

**JwtFilter**
```java
@Component
public class JwtFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
        throws IOException, ServletException {

        HttpServletRequest httpRequest = (HttpServletRequest) request;
        String authHeader = httpRequest.getHeader("Authorization");

        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);
            try {
                String username = JwtUtil.getUsername(token);
                httpRequest.setAttribute("username", username); // 요청에 사용자 정보 저장
            } catch (Exception e) {
                HttpServletResponse httpRes = (HttpServletResponse) response;
                httpRes.setStatus(HttpStatus.UNAUTHORIZED);
                return;
            }
        }

        chain.doFilter(request, response);
    }
}
```

**WebConfig에 Filter 등록**
```java
@Configuration
public class WebConfig {
    @Bean
    public FilterRegistrationBean<JwtFilter> jwtFilter() {
        FilterRegistrationBean<JwtFilter> filter = new FilterRegistrationBean<>();
        filter.setFilter(new JwtFilter());
        filter.addUrlPatterns("/api/*"); // 인증 필요 경로
        return filter;
    }
}
```

**인증 필요한 Controller**
```java
@RestController
@RequestMapping("/api/posts")
public class PostController {

    @GetMapping("/me")
    public ResponseEntity<?> myPage(HttpServletRequest request) {
        String username = (String) request.getAttribute("username");
        if (username == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("인증 필요");
        }
        return ResponseEntity.ok("사용자: " + username);
    }
}
```

<br>

## 6. 로그아웃 구현 예시

### 기본 방법: 클라이언트에서 JWT 삭제
- 서버는 상태 저장을 하지 않기 때문에 토큰을 **서버 측에서 무효화할 수 없음**
- 클라이언트에서 `localStorage`, `sessionStorage`, 또는 쿠키에 저장된 JWT를 삭제하면 로그아웃

### 확장 방법: 블랙리스트 방식 (선택 사항)
- 로그아웃 요청 시 토큰을 서버 저장소에 기록 (예: Redis)
- 필터에서 요청마다 토큰이 블랙리스트에 있는지 확인

**블랙리스트 방식 예시**
```java
@PostMapping("/logout")
public ResponseEntity<?> logout(HttpServletRequest request) {
    String token = request.getHeader("Authorization").substring(7);
    blacklistService.add(token); // Redis나 Map 등에 저장
    return ResponseEntity.ok("로그아웃 완료");
}
```

<br>

## 7. 주의사항

| 항목 | 설명 |
|------|------|
| 토큰 만료 설정 | 짧게 유지하여 탈취 위험 감소 (보통 15분~1시간) |
| Refresh Token 도입 | Access Token 만료 시, Refresh Token으로 재발급 가능 |
| HTTPS 사용 | JWT가 평문으로 전송되므로 HTTPS로 보안을 유지해야 함 |
| 민감 정보 저장 금지 | JWT Payload는 누구나 열람 가능하므로 개인정보 저장 금지 |

<br>
<hr>