+++
title = "사용자 정보 정규 표현식으로 검증하기"
date = "2025-04-01T16:13:32+09:00"
draft = true
topic = ["TIL"]
tag = ["내일배움캠프", "Java", "과제", "일정_관리_API", "정규_표현식"]
+++

<hr>
<br>

```
^[^@\s]+@[^@\s]+\.[^@\s]+$
```

이제 이걸 아주 작게 쪼개서, **1글자 단위로 어떤 의미인지** 하나하나 설명해드릴게요.

---

### ✅ 1. `^`

- 의미: **문자열의 시작**을 의미해요.
- 이걸 안 쓰면 중간에 일치하는 부분만 있어도 통과될 수 있어요.
- 그래서 전체 이메일이 정확히 이 패턴을 따라야 한다는 걸 말해줘요.

---

### ✅ 2. `[^@\s]+`

이 부분이 좀 복잡하죠. 이건 괄호 안을 먼저 볼게요.

#### 🔸 `[]` 대괄호: **"문자 클래스"**  
- 이 안에 있는 문자 중 하나와 일치하라는 뜻이에요.

#### 🔸 `^` (대괄호 안에서): **"부정"**  
- 대괄호 안에서 `^`는 "이 안에 있는 **문자는 제외하고** 일치"라는 뜻이에요.

#### 🔸 `@`와 `\s`  
- `@`는 그냥 문자 `@`
- `\s`는 **공백 문자** (띄어쓰기, 탭, 줄바꿈 등)

그래서 `[^@\s]`는 이렇게 해석돼요:

> **"공백이나 @를 제외한 모든 문자 중 하나"**

#### 🔸 마지막 `+`는?

- `+`는 **"앞의 문자가 1개 이상 반복됨"**을 뜻해요.

#### ✅ 최종 해석:

```plaintext
[^@\s]+ → 공백이나 @를 제외한 문자가 1개 이상
```

즉, `@` 앞의 문자열은  
- `공백도 없고`,  
- `@도 포함되지 않은`  
- 문자들이 최소 1글자 이상이어야 한다는 뜻이에요.

---

### ✅ 3. `@`

- 이건 이메일에서 반드시 들어가는 `@` 기호예요.
- 문자로서의 `@`를 그대로 의미해요.

---

### ✅ 4. 다시 `[^@\s]+`

- 아까랑 같은 패턴이에요.
- 이번엔 **@ 뒤의 도메인 이름 부분**을 검사해요.
- `gmail`, `naver`, `company` 같은 부분이에요.

즉, `@뒤에도 공백이나 @는 들어가면 안 되고, 최소 1글자 이상 있어야 한다`는 조건이에요.

---

### ✅ 5. `\.`

- `.`은 정규표현식에서 **"아무 문자"**라는 특수 의미가 있어요.
- 그래서 진짜 **문자 "."을 쓰고 싶을 땐 역슬래시(`\`)로 이스케이프** 해야 해요.
- `\.`는 **진짜 점(.)**을 뜻해요.

---

### ✅ 6. 또 `[^@\s]+`

- 마지막 도메인 끝 부분 (`com`, `net`, `co.kr`의 `kr` 같은 부분)
- 마찬가지로 `공백, @ 없이 1글자 이상이면 통과`예요.

---

### ✅ 7. `$`

- `^`가 시작을 뜻했다면,  
- `$`는 **문자열의 끝**을 뜻해요.

그래서 이 패턴은 **처음부터 끝까지 전체가 이 구조여야만 통과**돼요.

---

### 📌 전체 요약

| 부분 | 의미 |
|------|------|
| `^` | 문자열 시작 |
| `[^@\s]+` | @나 공백이 아닌 글자 1개 이상 (아이디) |
| `@` | @ 기호 |
| `[^@\s]+` | @ 뒤의 도메인 (예: gmail) |
| `\.` | 진짜 점(.) |
| `[^@\s]+` | 마지막 도메인 이름 (예: com) |
| `$` | 문자열 끝 |

---

### 🎯 이 정규표현식이 의미하는 건?

> **"공백 없이, @ 앞뒤로 글자가 있어야 하고, 도메인 부분에 점(.)이 꼭 1개 이상 포함되어야 하며, 마지막 점 뒤에도 글자가 있어야 한다."**

---

이름

```
regexp = "^[\\p{L}]+$"
```
\\p{L}은 모든 유니코드 문자 중에서 'Letter(문자)'인 것들을 뜻해요.  
즉, 영어, 한글, 프랑스어, 독일어, 일본어 히라가나/가타카나 등 사람 이름에 쓰일 수 있는 문자 전부 포함됨

---

비밀번호

### 🔐 비밀번호 정규표현식: 가장 자주 쓰는 예시

```java
@Pattern(
    regexp = "^(?=.*[A-Za-z])(?=.*\\d)(?=.*[!@#$%^&*])[A-Za-z\\d!@#$%^&*]{8,}$",
    message = "비밀번호는 8자 이상이며, 영문자, 숫자, 특수문자를 모두 포함해야 해요."
)
```

| 조건 | 설명 |
|------|------|
| `(?=.*[A-Za-z])` | 영문자 최소 1개 포함 |
| `(?=.*\\d)` | 숫자 최소 1개 포함 |
| `(?=.*[!@#$%^&*])` | 특수문자 최소 1개 포함 |
| `{8,}` | 총 8자 이상

---

### 💬 전체 정규표현식

```regexp
^(?=.*[A-Za-z])(?=.*\d)(?=.*[!@#$%^&*])[A-Za-z\d!@#$%^&*]{8,}$
```

---

## 1️⃣ `^`

- 의미: 문자열의 **시작**
- 이 정규표현식은 **문자열 전체가 이 규칙을 따라야 함**을 말해요

---

## 2️⃣ `(?=.*[A-Za-z])`

이게 뭔가 복잡하죠?  
하나씩 나눠서 설명할게요.

### 🔹 `(?= ... )` → **전방탐색 (Positive Lookahead)**

- 말 그대로 **"이 조건이 뒤에 있어야 한다"**는 뜻이에요.
- 실제로 그 문자를 소비하지는 않아요, **존재 여부만 체크해요.**

### 🔹 `.*` → 아무 문자나 0개 이상

- `.` → 아무 문자 한 개  
- `*` → 0개 이상 반복

즉, `.*[A-Za-z]`는  
> **"아무 문자들이 이어지다가, 영문자가 적어도 1개는 나와야 해"**

### 🔸 전체 해석: `(?=.*[A-Za-z])`

> 문자열 어딘가에 **영문자**가 **최소 1개 이상 있어야 한다**

---

## 3️⃣ `(?=.*\d)`

- `\d`는 숫자(0~9)를 의미해요.
- 나머지는 위와 동일한 구조

### 전체 해석:

> 문자열 어딘가에 **숫자**가 **최소 1개 이상 있어야 한다**

---

## 4️⃣ `(?=.*[!@#$%^&*])`

- 이건 **특수문자들 중 하나라도 들어있어야 한다**는 조건이에요.

> 문자열 어딘가에 **!@#$%^&*** 중 **하나 이상 포함되어야 한다**

---

## 5️⃣ `[A-Za-z\d!@#$%^&*]{8,}`

이제 진짜 본문이에요.  
위에 전방탐색은 조건만 확인한 거고,  
이 부분은 **실제 입력 내용**을 제한하는 패턴이에요.

- `[A-Za-z\d!@#$%^&*]` → 허용 문자들
  - 영어 대문자: `A-Z`
  - 영어 소문자: `a-z`
  - 숫자: `\d` (또는 `0-9`)
  - 특수문자: `!@#$%^&*`

- `{8,}` → **8자 이상**

### 전체 해석:

> 입력된 문자열은 반드시  
> **위에서 정한 문자들만으로 구성되며, 총 8자 이상**이어야 한다

---

## 6️⃣ `$`

- 문자열의 **끝**

---

### ✅ 최종 요약: 전체 정규표현식 의미

```
^(?=.*[A-Za-z])(?=.*\d)(?=.*[!@#$%^&*])[A-Za-z\d!@#$%^&*]{8,}$
```

> 다음 조건을 모두 만족해야 함:
>
> 1. 영어 대소문자 최소 1개
> 2. 숫자 최소 1개
> 3. 특수문자 `!@#$%^&*` 중 최소 1개
> 4. 총 길이 8자 이상
> 5. 허용된 문자 외에는 사용 불가

---

### 📌 예시

| 비밀번호 | 통과 여부 | 이유 |
|----------|-----------|------|
| `abc123!@` | ✅ | 모든 조건 만족 |
| `abc123` | ❌ | 특수문자 없음 |
| `ABC!@#` | ❌ | 숫자 없음, 길이 짧음 |
| `12345678!` | ❌ | 영문 없음 |
| `aaaBBB111!!!` | ✅ | 길이, 구성 다 만족 |


<br>
<hr>