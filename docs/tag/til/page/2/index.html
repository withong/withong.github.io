<!DOCTYPE html>
<html lang="ko" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>TIL | withong</title>
<meta name="keywords" content="">
<meta name="description" content="Today I Learned">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/tag/til/">
<link crossorigin="anonymous" href="http://localhost:1313/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/icons/code.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/icons/code.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/icons/code.png">
<link rel="apple-touch-icon" href="http://localhost:1313/icons/zep.png">
<link rel="mask-icon" href="http://localhost:1313/icons/zep.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tag/til/index.xml">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/tag/til/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="withong (Alt + H)">withong</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/log/" title="Log">
                    <span>Log</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/record/" title="Record">
                    <span>Record</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/project/" title="Project">
                    <span>Project</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tag/" title="Tag">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/tag/">Tag</a></div>
  <h1>
    TIL
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring 기초 2
    </h2>
  </header>
  <div class="entry-content">
    <p> 1. 프레임워크와 라이브러리 프레임워크 (Framework) 소프트웨어 개발을 간편하게 만들기 위한 개발 환경. 일정한 틀(Frame) 안에서 개발해야 하며, 개발의 일관성을 제공함. 장점: 코드의 일관성, 보안 강화, 테스트 환경 제공, 커뮤니티 지원. 단점: 학습 곡선이 높음, 새로운 버전과의 호환성 문제 발생 가능, 구조 변경 어려움. 라이브러리 (Library) 특정 기능을 수행하는 코드의 모음. 개발자가 필요할 때 가져다 사용 가능. 장점: 개발 생산성 증가, 안정성이 높은 코드 활용 가능. 단점: 업데이트 또는 지원 중단 시 문제 발생, 호환성 이슈. 2. Annotation 코드에 메타데이터를 추가하는 기능으로, 컴파일러나 런타임에서 특정 동작을 트리거함.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-18 17:32:05 +0900 KST'>2025년 3월 18일</span></footer>
  <a class="entry-link" aria-label="post link to Spring 기초 2" href="http://localhost:1313/record/2025-03-18-01/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring 기초 1
    </h2>
  </header>
  <div class="entry-content">
    <p> 네트워크 인터넷(Internet) TCP/IP 기반으로 동작하는 글로벌 네트워크. 데이터 전송을 위해 유선(해저 케이블) 및 무선(위성 통신) 활용. 인터넷 프로토콜(IP, Internet Protocol) 네트워크 내에서 기기를 식별하는 주소 체계. 예시: 192.168.0.1 IP 방식의 문제점 애플리케이션 구분 불가능. 비연결성: 수신 대상의 상태를 고려하지 않고 전송. 비신뢰성: 패킷 손실 및 순서 뒤섞임 가능. TCP와 UDP TCP(Transmission Control Protocol) 신뢰성 있는 데이터 전송 (3-Way Handshake 방식). 패킷 순서 보장 및 오류 검출 가능. UDP(User Datagram Protocol) 빠른 전송 속도를 우선시 (비신뢰성 전송). 실시간 스트리밍, 온라인 게임 등에 사용. PORT 같은 IP에서 여러 프로세스를 구분하는 번호. 주요 포트 번호: HTTP(80), HTTPS(443), FTP(21), SSH(22). Web DNS(Domain Name System) 도메인과 IP 주소를 매핑하는 시스템. 사람이 이해하기 쉬운 도메인(google.com)을 IP 주소로 변환. URI(Uniform Resource Identifier) 인터넷 자원의 고유 식별자. URL(Uniform Resource Locator) 리소스의 위치를 나타내는 형식 (https://spartacodingclub.kr/). 브라우저에 URL을 입력하면 사용자가 브라우저에 URL을 입력. DNS 조회를 통해 도메인에 해당하는 IP 주소 확인. 웹 브라우저가 HTTP 요청을 생성. 요청 패킷이 서버로 전송. 서버에서 HTTP 요청을 처리 후 응답 생성. 응답 패킷이 클라이언트로 전송. 브라우저가 응답 데이터를 렌더링하여 화면 표시. 용어 모음 프로그래밍 명명규칙(Casing) snake_case: Python, DB 테이블에서 사용 (user_name). camelCase: Java, JavaScript에서 변수 및 메서드 이름에 사용 (userName). PascalCase: 클래스 및 객체 이름에 사용 (UserName). kebab-case: URL 및 CSS에서 사용 (user-name). JSON(JavaScript Object Notation) 클라이언트-서버 간 데이터 교환을 위한 경량 데이터 포맷. XML 대비 가독성이 뛰어나고 용량이 작음. Scale Up, Scale Out Scale Up: 단일 서버의 성능 향상 (CPU, RAM 증가). Scale Out: 여러 대의 서버 확장 (부하 분산). Stateful vs Stateless Stateful: 클라이언트의 상태를 유지해야 하는 서비스. Stateless: 서버가 클라이언트 상태를 저장하지 않음 (확장성 우수). Connection vs Connectionless Connection: 지속적 연결 유지 (HTTP/1.0). Connectionless: 필요할 때만 연결 (HTTP/1.1, HTTP/2). HTTP HTTP(HyperText Transfer Protocol) 인터넷 상에서 클라이언트와 서버 간 데이터를 교환하는 프로토콜. HTTP 특징 Stateless(무상태): 클라이언트의 상태를 저장하지 않음. Connectionless(비연결): 요청-응답 후 연결을 끊음. HTTP Message 구조 Request (요청) Start Line: HTTP Method, URL, HTTP Version. Header: 추가적인 요청 정보 (예: Content-Type). Body: 요청 데이터 포함 (POST 요청 등). Response (응답) Status Code: 요청의 처리 결과 (200 OK, 404 Not Found 등). Header: 응답 메타데이터. Body: 응답 데이터. HTTP Method와 상태 코드 HTTP Method GET: 데이터 조회. POST: 데이터 생성. PUT: 데이터 전체 수정. PATCH: 데이터 일부 수정. DELETE: 데이터 삭제. HTTP 상태 코드 200 OK: 정상 응답. 201 Created: 리소스 생성 완료. 400 Bad Request: 잘못된 요청. 401 Unauthorized: 인증 필요. 404 Not Found: 리소스 없음. 500 Internal Server Error: 서버 내부 오류. HTTP Header HTTP Header의 역할 요청과 응답의 부가 정보 제공. 자주 사용하는 Header Content-Type: 데이터 형식 지정 (application/json). Authorization: 인증 정보 포함. Cache-Control: 캐시 정책 (max-age, no-cache 등). Set-Cookie: 쿠키 설정 (세션 관리). Restful API REST (Representational State Transfer) 리소스를 기반으로 한 API 설계 원칙. RESTful API 설계 예시 POST /boards → 게시글 생성. GET /boards → 게시글 목록 조회. GET /boards/{id} → 특정 게시글 조회. PUT /boards/{id} → 게시글 수정. DELETE /boards/{id} → 게시글 삭제. Web Application Web Server vs WAS(Web Application Server) Web Server: 정적 콘텐츠 제공 (예: Nginx, Apache). WAS: 동적 콘텐츠 처리 (예: Tomcat, Spring Boot). Web System 구성 프론트엔드(클라이언트) → 백엔드(WAS) → 데이터베이스(DB). Servlet Servlet Java 기반 웹 애플리케이션을 처리하는 기술. Servlet 동작 순서 클라이언트가 요청 전송. Servlet Container가 요청을 분석하여 Servlet 실행. Servlet이 요청을 처리하고 응답 생성. 응답이 클라이언트에게 전달됨. Thread Thread 하나의 프로세스 내에서 실행되는 작업 단위. Multi-Thread 여러 작업을 동시에 실행하는 기술 (서버 성능 향상 가능). SSR(Server Side Rendering) vs CSR(Client Side Rendering) SSR: 서버에서 HTML을 생성하여 클라이언트로 전송 (초기 로딩 속도 빠름). CSR: 클라이언트에서 JavaScript를 이용해 동적으로 렌더링 (SPA에서 주로 사용). </p>
  </div>
  <footer class="entry-footer"><span title='2025-03-17 22:00:03 +0900 KST'>2025년 3월 17일</span></footer>
  <a class="entry-link" aria-label="post link to Spring 기초 1" href="http://localhost:1313/record/2025-03-17/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Collection &amp; Stream
    </h2>
  </header>
  <div class="entry-content">
    <p> 1. 배열 vs. 컬렉션 배열: 크기 고정, 동일 타입 데이터만 저장, 인덱스로 접근 가능, 단순한 구조. 컬렉션: 크기 동적 조절 가능, 다양한 타입 지원(제네릭), List/Set/Map 등 다양한 자료구조 제공. 2. 컬렉션 주요 인터페이스 List (ArrayList, LinkedList): 순서 O, 중복 O, 인덱스로 접근 가능. Set (HashSet, TreeSet): 순서 X, 중복 X. Map (HashMap, TreeMap): 키-값 쌍 저장, 키 중복 X, 값 중복 O. 3. 원시 타입 vs. 래퍼 클래스 컬렉션에는 원시 타입(int, char)을 직접 저장할 수 없고, 래퍼 클래스(Integer, Character)를 사용해야 함. 래퍼 클래스는 객체로 취급되며, 다양한 메서드를 제공. 4. 스트림(Stream) 자바 8에서 도입된 데이터 처리 방식. 원본 데이터를 변경하지 않고 가공 가능. 중간 연산(필터링, 변환)과 최종 연산(집계, 출력)으로 구성됨. 5. 스트림 주요 연산 중간 연산 (Intermediate Operations)
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-13 21:00:00 +0900 KST'>2025년 3월 13일</span></footer>
  <a class="entry-link" aria-label="post link to Collection & Stream" href="http://localhost:1313/record/2025-03-13/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Enum &amp; 동일성/동등성
    </h2>
  </header>
  <div class="entry-content">
    <p> Enum → 단순한 상수의 모음이 아니라, 객체처럼 동작하는 데이터 타입 동등성 (equals()) → 내용이 같으면 true 동일성 (==) → 메모리 주소가 같으면 true hashCode() → 컬렉션에서 일관성 있게 동작하도록 필수적으로 재정의해야 한다. 1. Enum (열거형) Enum은 서로 연관된 상수들의 집합을 정의하는 특별한 데이터 타입이다.
기존 final static 상수를 사용하는 것보다 더 안전하고 가독성이 좋다.
Enum의 특징 상수들의 집합으로 사용된다. 내부적으로 final class처럼 동작하며, 새로운 인스턴스를 생성할 수 없다. 객체처럼 필드와 메서드를 가질 수 있다. 타입 안정성을 제공한다. enum Day { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY; } Day는 요일을 표현하는 상수 그룹이다.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-11 10:44:41 +0900 KST'>2025년 3월 11일</span></footer>
  <a class="entry-link" aria-label="post link to Enum & 동일성/동등성" href="http://localhost:1313/record/2025-03-11/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Java 심화 2
    </h2>
  </header>
  <div class="entry-content">
    <p> ✅ [강의] Java 문법 세션 2 - 객체 활용
✅ [강의] Java 문법 Chapter 3 (5~7)
✅ [과제] Java 계산기 만들기 level 2
람다(Lambda) 함수형 인터페이스 람다식을 사용하기 위한 인터페이스 단 하나의 추상 메서드만 포함해야 함. @FunctionalInterface 애노테이션을 사용. @FunctionalInterface // 함수형 인터페이스 선언 public interface Calculator { int sum(int a, int b); // 오직 하나의 추상 메서드만 선언해야 함 } 익명 클래스 별도의 클래스 파일을 만들지 않고 코드 내에서 일회성으로 정의해 사용하는 클래스. 주로 인터페이스를 구현할 때나 클래스를 상속할 때 간단한 기능을 위해 사용됨. public static void main(String[] args) { // 인터페이스를 활용한 익명 클래스 만들기 Calculator calculator1 = new Calculator() { @Override public int sum(int a, int b) { return a &#43; b; } }; int ret1 = calculator1.sum(2, 2); System.out.println(&#34;ret1 = &#34; &#43; ret1); } 람다식 메서드를 하나의 식(Expression)으로 표현하는 방식 익명 함수(Anonymous Function)와 유사 함수형 인터페이스와 함께 사용됨 불필요한 코드 생략 가능 → 간결한 코드 작성 가능 public static void main(String[] args) { // 인터페이스를 활용한 람다식 만들기 Calculator calculator = (a, b) -&gt; a &#43; b; int ret = calculator.sum(3, 3); System.out.println(&#34;ret = &#34; &#43; ret); } 람다식 활용 public static void main(String[] args) { // 람다식을 매개변수로 전달하는 방법 // 1. 익명 클래스를 변수에 담아 매개변수로 전달 Calculator cal1 = new Calculator() { @Override public int sum(int a, int b) { return a &#43; b; } }; int ret1 = calculator(3, 3, cal1); System.out.println(&#34;ret1 = &#34; &#43; ret1); // 2. 람다식을 변수에 담아 매개변수로 전달 Calculator cal2 = (a, b) -&gt; a &#43; b; int ret2 = calculator(4, 4, cal2); System.out.println(&#34;ret2 = &#34; &#43; ret2); // 3. 람다식을 직접 매개변수로 전달 int ret3 = calculator(5, 5, (a, b) -&gt; a &#43; b); System.out.println(&#34;ret3 = &#34; &#43; ret3); } public static int calculator(int a, int b, Calculator calculator) { return calculator.sum(a, b); } 스트림(Stream) 데이터의 흐름을 표현하는 기능으로, 배열이나 컬렉션 등의 데이터를 함수형 스타일로 처리할 수 있도록 지원하는 API
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-02-27 21:00:00 +0900 KST'>2025년 2월 27일</span></footer>
  <a class="entry-link" aria-label="post link to Java 심화 2" href="http://localhost:1313/record/2025-02-27/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Java 심화 1
    </h2>
  </header>
  <div class="entry-content">
    <p> ✅ [강의] Java 문법 Chapter 3 (1~4)
✅ [과제] Java 계산기 만들기 level 1
예외와 예외 처리 예외 → 프로그램 실행 중 발생할 수 있는 예기치 못한 오류나 상황. 예외가 처리되지 않으면 프로그램 흐름이 중단됨.
예외 구조와 종류
UncheckedException → RuntimeException과 그 하위 클래스. 예외 처리 강제되지 않음. 예: NullPointerException, ArrayIndexOutOfBoundsException CheckedException → RuntimeException을 제외한 예외. 예외 처리 강제됨. 예: IOException, SQLException. 예외 전파
UncheckedException → 예외 전파가 자동으로 이루어짐. → main() 메서드나 스레드에서 처리하지 않으면 프로그램이 종료됨. CheckedException → 예외가 발생했을 때 반드시 예외를 처리하거나 전파해야 함. → try-catch문 또는 메서드 선언에 throws 키워드 사용. Optional Optional&lt;T&gt; → Null을 안전하게 다루기 위한 클래스
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-02-26 21:00:00 +0900 KST'>2025년 2월 26일</span></footer>
  <a class="entry-link" aria-label="post link to Java 심화 1" href="http://localhost:1313/record/2025-02-26/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">객체지향
    </h2>
  </header>
  <div class="entry-content">
    <p> ✅ 문법 세션 1 - 프로그래밍 기초
✅ Java 문법 강의 2주차
Chapter 2. 객체지향 이해하기 클래스와 객체 클래스(class) → 객체를 생성하기 위한 설계도. 속성과 기능을 정의하며, 동일한 구조를 가진 객체를 여러 개 생성할 수 있음. 객체(object) → 클래스를 기반으로 생성된 실체. 메모리에 할당되어 동작하며, 개별적으로 속성과 기능을 가짐. 인스턴스화(instantiate) → 클래스를 이용해 객체를 생성하는 과정. new 키워드를 사용해 객체를 메모리에 할당. 속성(property, field) → 객체가 가지는 데이터. 클래스 내부에서 변수 형태로 선언되며, 객체마다 서로 다른 값을 가질 수 있음. 생성자(constructor) → 객체가 생성될 때 호출되는 특수한 메서드. 속성을 초기화하고, 객체의 기본 상태를 설정하는 역할. 기능(method) → 객체가 수행하는 동작. 클래스 내부에서 정의되며, 특정 입력을 받아 처리한 후 결과를 반환하거나 상태를 변경함. JVM 메모리 영역 Method Area → 클래스 정보(클래스 이름, 메서드, 필드, static 변수 등)를 저장하는 공간. JVM이 시작될 때 로드되며, 모든 쓰레드가 공유. Stack Area → 메서드 호출 시 생성되는 스택 프레임을 저장하는 공간. 지역변수, 매개변수, 메서드 호출 정보가 포함되며, 호출이 끝나면 제거. 각 쓰레드마다 독립적인 스택을 가짐. Heap Area → 객체와 인스턴스 변수가 저장되는 공간. new 키워드로 생성된 객체가 저장되며, GC(Garbage Collector)가 관리. 모든 쓰레드가 공유. 래퍼클래스 래퍼클래스 → 기본형 데이터를 객체처럼 다룰 수 있도록 감싸는 클래스. Integer, Double, Boolean 등 기본형의 객체화된 버전.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-02-25 21:00:00 +0900 KST'>2025년 2월 25일</span></footer>
  <a class="entry-link" aria-label="post link to 객체지향" href="http://localhost:1313/record/2025-02-25-02/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">final
    </h2>
  </header>
  <div class="entry-content">
    <p>final -지역변수 final이 붙은 지역변수는 한 번만 값을 할당할 수 있음. 값이 할당된 이후에는 변경 불가능. 메서드의 매개변수에도 final을 적용할 수 있으며, 이 경우 해당 매개변수 값 변경이 불가능. public class FinalLocalMain { public static void main(String[] args) { // final 지역변수1 - 선언 후 할당 (한 번만 가능) final int data1; data1 = 10; // 최초 할당 가능 // data1 = 20; // 오류! final 변수는 한 번만 할당 가능 // final 지역변수2 - 선언과 동시에 초기화 final int data2 = 10; // data2 = 20; // 오류! 이미 값이 설정됨 method(10); } // final 매개변수 (메서드 내부에서 변경 불가능) static void method(final int parameter) { // parameter = 20; // 오류! final 매개변수는 값 변경 불가 } } final 지역변수는 최초 한 번만 값을 할당 가능, 이후 변경 불가. final 매개변수는 메서드 내부에서 값 변경이 불가능. final - 필드(멤버변수) 클래스의 멤버 변수(필드)에 final을 사용하면, 해당 필드는 한 번만 초기화 가능함.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-02-25 09:00:00 +0900 KST'>2025년 2월 25일</span></footer>
  <a class="entry-link" aria-label="post link to final" href="http://localhost:1313/record/2025-02-25-01/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Java 기초
    </h2>
  </header>
  <div class="entry-content">
    <p> ✅ Java 문법 강의 1주차
Chapter 1. Java 기초 문법 다지기 JDK (Java Development Kit) JDK → Java 프로그램을 개발할 때 필요한 개발 도구 모음 Javac(Java Compiler) → 자바코드를 바이트코드(.class)로 변환 JVM (Java Virtual Machine) → 바이트코드를 실행 컴퓨터의 기억 방식 RAM (메모리) → 휘발성, 프로그램 실행 시 사용됨 보조기억장치 (HDD, SSD) → 영구 저장 비트(Bit) → 0 또는 1의 값 바이트(Byte) → 8비트로 구성 자바 프로젝트 관리 네이밍 규칙 카멜케이스 (camelCase) → 변수, 메서드 (myVariableName) 스네이크케이스 (snake_case) → (Java에서는 잘 사용하지 않음) 클래스 이름 → PascalCase (MyClass) 패키지 이름 → 소문자 (com.example.app) 변수와 자료형 변수 → 데이터를 저장하는 공간 자료형 기본형: int, double, char, boolean 참조형: String, Array, Class int num = 10; // 정수형 변수 double pi = 3.14; // 실수형 변수 boolean isJavaFun = true; // 논리형 변수 형변환 업캐스팅(작은 → 큰 자료형) → 자동 변환 다운캐스팅(큰 → 작은 자료형) → 강제 변환 double d = 10; // 자동 형변환 (업캐스팅) int i = (int) d; // 강제 형변환 (다운캐스팅) 입출력 (I/O) 입력 (Scanner 사용) import java.util.Scanner; Scanner scanner = new Scanner(System.in); int num = scanner.nextInt(); // 정수 입력 출력 (System.out 사용) System.out.println(&#34;Hello Java!&#34;); // 개행 포함 출력 System.out.print(&#34;No new line&#34;); // 개행 없이 출력 System.out.println(&#34;\n줄 바꿈 포함&#34;); // `\n` 사용 연산자 산술 연산자(&#43;, -, *, /, %) 대입 연산자(=) 복합 대입 연산자(&#43;=, -=, *=, /= , %=) 증감 연산자(&#43;&#43;, --) 전위 연산 - 사용 전 연산 후위 연산 - 사용 후 연산 비교 연산자(==, !=, &lt;, &gt;, &lt;=, &gt;=) 논리 연산자(!, &amp;&amp;, ||) 문자열 비교(equals()) 조건문 import java.util.Scanner; Scanner scanner = new Scanner(System.in); System.out.print(&#34;신호등 색상을 입력하세요(초록불, 노란불, 빨간불): &#34;); String light = scanner.nextLine(); if (light.equals(&#34;초록불&#34;)) { System.out.println(&#34;건너세요!&#34;); } else if (light.equals(&#34;노란불&#34;)) { System.out.println(&#34;주의하세요!&#34;); } else if (light.equals(&#34;빨간불&#34;)) { System.out.println(&#34;멈추세요!&#34;); } else { System.out.println(&#34;잘못된 입력입니다!&#34;); } switch (light) { case &#34;초록불&#34;: System.out.println(&#34;건너세요!&#34;); break; case &#34;노란불&#34;: System.out.println(&#34;주의하세요!&#34;); break; case &#34;빨간불&#34;: System.out.println(&#34;멈추세요!&#34;); break; default: System.out.println(&#34;잘못된 입력입니다!&#34;); } 반복문 for (int i = 0; i &lt; 5; i&#43;&#43;) { System.out.print(i &#43; &#34; &#34;); // 0 1 2 3 4 } int i = 0; while (i &lt; 5) { System.out.print(i &#43; &#34; &#34;); i&#43;&#43;; } int i = 0; do { System.out.print(i &#43; &#34; &#34;); i&#43;&#43;; } while (i &lt; 5); 배열 // 1. 배열 선언 int[] arr1; // 2. 배열 길이 할당 arr1 = new int[5]; // 3. 배열 선언과 길이 동시에 할당 int[] arr2 = new int[5]; // 4. 배열 선언과 동시에 배열의 요소 할당 int[] arr3 = {10, 20, 30, 40, 50}; // 배열의 길이 int arrLength = arr3.length; System.out.println(&#34;arrLength = &#34; &#43; arrLength); // 배열 요소 접근 System.out.println(&#34;배열의 1번째 요소 접근: &#34; &#43; arr3[0]); // 배열 요소 변경 arr3[0] = 100; // 향상된 for 문 for (int a : arr3) { System.out.println(&#34;a = &#34; &#43; a); } // 2차원 배열 int[][] arr4 = { {1, 2}, {3, 4} }; System.out.println(arr4[1][0]); // 3 메서드 public class Calculator { // 두 정수를 더하는 메서드 (반환값 있음: int) int sum(int value1, int value2) { int result = value1 &#43; value2; // 두 값 더하기 return result; // 결과 반환 } // 반환값이 없는 메서드 (void) void printSum(int value1, int value2) { int result = value1 &#43; value2; System.out.println(&#34;result = &#34; &#43; result); } } public class Main { public static void main(String[] args) { Calculator calculator = new Calculator(); // Calculator 객체 생성 // sum 메서드는 반환값이 있어서 변수에 저장 int result = calculator.sum(1, 2); System.out.println(&#34;result = &#34; &#43; result); // printSum 메서드는 반환값이 없고 바로 출력됨 calculator.printSum(3, 4); } } result = 3result = 7 </p>
  </div>
  <footer class="entry-footer"><span title='2025-02-24 21:00:00 +0900 KST'>2025년 2월 24일</span></footer>
  <a class="entry-link" aria-label="post link to Java 기초" href="http://localhost:1313/record/2025-02-24/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Git
    </h2>
  </header>
  <div class="entry-content">
    <p> Chapter 1. 온보딩 주차
✅ [특강] Git
✅ 미니 프로젝트 S.A
Git 1. 기본 명령어 명령어 기능 git init 현재 폴더를 Git 저장소로 초기화 git status 현재 저장소의 상태 확인 (추적되지 않은 파일, 변경 사항 등) git add &lt;파일명&gt; 특정 파일을 스테이징 영역에 추가 git add . 변경된 모든 파일을 스테이징 영역에 추가 git commit -m &#34;메시지&#34; 스테이징된 파일을 저장소에 커밋 git log 커밋 내역 확인 git log --oneline 한 줄 요약된 커밋 내역 확인 git config --global user.name &#34;이름&#34; Git 전역 사용자 이름 설정 git config --global user.email &#34;이메일&#34; Git 전역 이메일 설정 git config --list 설정된 Git 사용자 정보 확인 2. 브랜치 관련 명령어 명령어 기능 git branch 현재 존재하는 브랜치 목록 확인 git branch &lt;브랜치명&gt; 새로운 브랜치 생성 git checkout &lt;브랜치명&gt; 해당 브랜치로 이동 git checkout -b &lt;브랜치명&gt; 브랜치 생성 후 바로 이동 git merge &lt;브랜치명&gt; 현재 브랜치에 다른 브랜치를 병합 git branch -d &lt;브랜치명&gt; 특정 브랜치 삭제 git branch -D &lt;브랜치명&gt; 브랜치 강제 삭제 git branch -M main 브랜치 이름 변경 (기본 브랜치를 main으로 변경) 3. 원격 저장소(GitHub) 관련 명령어 명령어 기능 git remote add origin &lt;저장소 URL&gt; 원격 저장소 추가 (GitHub와 연결) git remote -v 원격 저장소 목록 확인 git push origin main 현재 브랜치를 원격 저장소의 main 브랜치에 업로드 git push -u origin main 기본 업스트림 브랜치 설정 후 푸시 git push --force 강제 푸시 (주의 필요) git pull origin main 원격 저장소의 최신 변경 사항 가져오기 git remote remove origin 원격 저장소 연결 해제 git clone &lt;저장소 URL&gt; 원격 저장소를 로컬로 복제 4. 파일 관리 및 변경 사항 되돌리기 명령어 기능 git reset --soft HEAD~1 마지막 커밋 취소 (파일 변경 사항 유지) git reset --hard HEAD~1 마지막 커밋 취소 (변경 사항도 삭제) git checkout -- &lt;파일명&gt; 특정 파일의 변경 사항 취소 git stash 변경 사항을 임시 저장 git stash pop 임시 저장한 변경 사항 적용 git revert &lt;커밋ID&gt; 특정 커밋을 취소하는 새로운 커밋 생성 5. 협업 및 충돌 해결 명령어 기능 git fetch origin 원격 저장소의 변경 사항 가져오기 (병합 X) git pull origin main 원격 저장소에서 최신 코드 가져오기 (병합 O) git merge &lt;브랜치명&gt; 브랜치를 병합 git mergetool 충돌 해결 도구 실행 git rebase &lt;브랜치명&gt; 다른 브랜치 위에 현재 브랜치를 재배치 git reset --hard origin/main 원격 저장소 기준으로 강제 리셋 git cherry-pick &lt;커밋ID&gt; 특정 커밋만 현재 브랜치에 적용 git diff 변경 사항 비교 git diff --staged 스테이징된 변경 사항 비교 git log --graph --all --decorate --oneline 브랜치와 커밋 히스토리를 그래프로 확인 6. 설정 및 기타 유용한 명령어 명령어 기능 git config --global core.editor &#34;vim&#34; 기본 텍스트 편집기 설정 git config --global core.autocrlf true 자동 줄바꿈 설정 (Windows) git gc Git 저장소 정리 및 최적화 git fsck 저장소의 무결성 검사 git blame &lt;파일명&gt; 특정 파일에서 누가 어떤 줄을 변경했는지 확인 7. 협업을 위한 기본 Workflow 1) GitHub에서 프로젝트 생성 후 클론 git clone &lt;저장소 URL&gt; cd 프로젝트 폴더 2) 새로운 브랜치에서 개발 진행 git checkout -b feature-branch 3) 변경 사항 저장 git add . git commit -m &#34;기능 추가&#34; 4) GitHub에 업로드 git push origin feature-branch 5) 메인 브랜치와 병합 git checkout main git merge feature-branch 6) 최신 코드 유지 git pull origin main 미니 프로젝트 S.A 📅 기간: 2025.02.17 - 2025.02.21
📝 프로젝트: 팀 &amp; 팀원 소개 웹 페이지
🎨 역할: 메인 페이지 및 팀원 정보 입력창 (HTML/CSS)
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-02-17 21:00:00 +0900 KST'>2025년 2월 17일</span></footer>
  <a class="entry-link" aria-label="post link to Git" href="http://localhost:1313/record/2025-02-17/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/tag/til/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/tag/til/page/3/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">withong</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
