<!DOCTYPE html>
<html lang="ko" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Spring | withong</title>
<meta name="keywords" content="">
<meta name="description" content="Today I Learned">
<meta name="author" content="">
<link rel="canonical" href="https://withong.github.io/tag/spring/">
<link crossorigin="anonymous" href="https://withong.github.io/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://withong.github.io/icons/rec.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://withong.github.io/icons/rec.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://withong.github.io/icons/rec.png">
<link rel="apple-touch-icon" href="https://withong.github.io/icons/rec.png">
<link rel="mask-icon" href="https://withong.github.io/icons/rec.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://withong.github.io/tag/spring/index.xml">
<link rel="alternate" hreflang="ko" href="https://withong.github.io/tag/spring/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://withong.github.io/tag/spring/">
  <meta property="og:site_name" content="withong">
  <meta property="og:title" content="Spring">
  <meta property="og:description" content="Today I Learned">
  <meta property="og:locale" content="ko">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring">
<meta name="twitter:description" content="Today I Learned">

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://withong.github.io/" accesskey="h" title="withong (Alt + H)">withong</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://withong.github.io/log/" title="Log">
                    <span>Log</span>
                </a>
            </li>
            <li>
                <a href="https://withong.github.io/record/" title="Record">
                    <span>Record</span>
                </a>
            </li>
            <li>
                <a href="https://withong.github.io/project/" title="Project">
                    <span>Project</span>
                </a>
            </li>
            <li>
                <a href="https://withong.github.io/tag/" title="Tag">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://withong.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://withong.github.io/">Log</a>&nbsp;»&nbsp;<a href="https://withong.github.io/tag/">Tag</a></div>
  <h1>
    Spring
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring Boot 단위 테스트 (JUnit 5 기반)
    </h2>
  </header>
  <div class="entry-content">
    <p>1. Controller 계층 테스트 목적 Controller는 클라이언트의 HTTP 요청을 받아 처리하고, 적절한 응답을 반환하는 역할을 한다. 따라서 Controller 테스트는 웹 요청과 응답 흐름을 검증하는 데 목적이 있으며, URL 매핑, 요청 파라미터 바인딩, 응답 상태 코드, 유효성 검사, 예외 처리 등이 올바르게 동작하는지를 확인한다.
사용 어노테이션 @WebMvcTest(ControllerClass.class): 대상 컨트롤러와 관련된 웹 계층 빈들만 로드한다. @MockBean: 컨트롤러가 의존하는 서비스 빈을 가짜 객체로 등록한다. @AutoConfigureMockMvc: @WebMvcTest에 포함되어 있으며, MockMvc를 주입받아 HTTP 요청 시뮬레이션이 가능하다. 사용 메서드 mockMvc.perform(...): 가상의 HTTP 요청을 보낸다. andExpect(...): 상태 코드나 응답 본문 등을 검증한다. when(...).thenReturn(...), given(...).willReturn(...): 의존 서비스의 동작을 미리 지정한다. verify(...): 서비스가 특정 메서드를 호출했는지 확인한다. 예시 코드 @WebMvcTest(UserController.class) class UserControllerTest { @Autowired private MockMvc mockMvc; @MockBean private UserService userService; @Test void getUser_성공() throws Exception { // given UserDto user = new UserDto(1L, &#34;홍길동&#34;); when(userService.getUser(1L)).thenReturn(user); // when &amp; then mockMvc.perform(get(&#34;/api/users/1&#34;)) .andExpect(status().isOk()) .andExpect(jsonPath(&#34;$.name&#34;).value(&#34;홍길동&#34;)); verify(userService).getUser(1L); } } 2. Service 계층 테스트 목적 Service는 핵심 비즈니스 로직을 처리하는 계층이다. 외부 의존성을 제외하고 서비스 로직 자체의 동작이 기대한 대로 수행되는지를 검증하는 것이 목적이다. 가능한 한 빠르고 독립적인 테스트를 위해 외부 의존성은 모두 mock으로 대체한다.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-04-21 19:23:14 +0900 KST'>2025년 4월 21일</span></footer>
  <a class="entry-link" aria-label="post link to Spring Boot 단위 테스트 (JUnit 5 기반)" href="https://withong.github.io/record/2025-04-21-02/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring AOP와 프록시
    </h2>
  </header>
  <div class="entry-content">
    <p>1. AOP란? AOP는 Aspect-Oriented Programming(관점 지향 프로그래밍) 의 약자로,
공통된 관심사를 핵심 비즈니스 로직과 분리하여 모듈화하는 프로그래밍 패러다임이다.
1.1 공통 관심사란? 애플리케이션 전반에 걸쳐 반복되지만 핵심 로직과 직접적인 관련은 없는 기능을 말한다.
로깅 트랜잭션 처리 보안 권한 검사 예외 로깅 실행 시간 측정 이러한 로직을 모든 메서드마다 직접 작성하면 코드 중복과 유지보수 비용이 증가하게 된다.
AOP는 이 문제를 해결하기 위해 공통 기능을 하나의 모듈로 분리하고,
weaving(위빙) 과정을 통해 실행 흐름에 자동으로 삽입하는 구조를 제공한다.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-04-21 12:46:19 +0900 KST'>2025년 4월 21일</span></footer>
  <a class="entry-link" aria-label="post link to Spring AOP와 프록시" href="https://withong.github.io/record/2025-04-21-01/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">JOIN FETCH vs @EntityGraph
    </h2>
  </header>
  <div class="entry-content">
    <p>JPQL이란? 정의 JPQL (Java Persistence Query Language) 는 JPA에서 사용하는 객체 지향 쿼리 언어
JPQL은 테이블이 아닌 ‘엔티티(Entity)‘를 기준으로 동작하는 쿼리 언어
예시 @Query(&#34;SELECT u FROM User u WHERE u.email = :email&#34;) User findByEmail(String email); User는 테이블 이름이 아니라 자바 클래스 이름 u.email도 컬럼 이름이 아니라 필드 이름 JPQL의 특징 항목 설명 대상 DB 테이블이 아닌 자바 엔티티 클래스 언어 SQL과 유사하지만, 객체 지향적으로 작성 실행 JPA가 내부적으로 JPQL → SQL 변환해서 실행 위치 @Query, EntityManager.createQuery(...) 등에서 사용 JPQL vs SQL 차이점 항목 JPQL SQL 기준 엔티티 클래스 데이터베이스 테이블 필드 참조 클래스 필드명 (u.email) 테이블 컬럼명 (u.email_address) 반환값 엔티티 객체 Row 데이터 결과 매핑 자동 (Entity로) 수동 또는 별도 설정 사용 위치 JPA 코드 내부 (@Query) DB 툴, Native Query 등 JPQL은 객체(Entity) 관점, SQL은 순수 데이터(Row) 관점
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-04-17 20:13:28 +0900 KST'>2025년 4월 17일</span></footer>
  <a class="entry-link" aria-label="post link to JOIN FETCH vs @EntityGraph" href="https://withong.github.io/record/2025-04-17-02/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring 심화 - 활용
    </h2>
  </header>
  <div class="entry-content">
    <p>1. Spring Bean의 생명주기 Spring에서 Bean은 컨테이너에 의해 생성되고 관리되며, 소멸까지 일련의 생명주기를 가진다. 개발자는 이 생명주기 중 특정 시점에서 동작하도록 콜백 메서드를 설정할 수 있다.
생명주기 전체 흐름 Spring 컨테이너 초기화: ApplicationContext 생성 Bean 인스턴스 생성: 일반적으로 기본 생성자 사용 의존성 주입: 생성자, 필드, setter 중 하나로 주입 초기화 콜백 실행: @PostConstruct, afterPropertiesSet() 등 Bean 사용 소멸 콜백 실행: @PreDestroy, destroy() 등 Bean 소멸 콜백 방식별 정리 1. 인터페이스 기반 InitializingBean.afterPropertiesSet() DisposableBean.destroy() Spring 프레임워크에 의존적이며, 외부 라이브러리에 적용 불가 2. 설정 메서드 기반 @Bean(initMethod = &#34;...&#34;, destroyMethod = &#34;...&#34;) 메서드명을 자유롭게 지정 가능, 외부 라이브러리에도 적용 가능 3. 표준 어노테이션 기반 (권장 방식) @PostConstruct: 의존성 주입 완료 후 초기화 @PreDestroy: 소멸 직전 실행 Spring이 아닌 환경에서도 사용 가능 Bean Scope Bean이 언제 생성되고 얼마나 유지되는지를 결정하는 설정이다.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-04-17 00:06:53 +0900 KST'>2025년 4월 17일</span></footer>
  <a class="entry-link" aria-label="post link to Spring 심화 - 활용" href="https://withong.github.io/record/2025-04-17-01/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring 심화 - JPA
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 연관관계 매핑 JPA는 객체 간의 연관관계를 데이터베이스의 외래 키로 매핑할 수 있도록 다음과 같은 어노테이션을 제공한다.
@ManyToOne: 다대일 관계 (예: 여러 게시글이 하나의 작성자와 연결됨) @OneToMany: 일대다 관계 (예: 하나의 주문이 여러 상품과 연결됨) @OneToOne: 일대일 관계 (예: 한 사람당 하나의 여권을 가짐) @ManyToMany: 다대다 관계 (예: 여러 사용자가 여러 관심사를 가질 수 있음) JPA에서 연관관계를 설계할 때는 반드시 외래 키(FK)를 어느 테이블이 관리할지 결정해야 하며, 이를 “연관관계의 주인”이라고 한다. 실제 외래 키는 항상 “다수 쪽(N쪽)“에 존재하며, 해당 필드를 가진 객체가 연관관계의 주인이 되어야 한다.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-04-16 23:43:34 +0900 KST'>2025년 4월 16일</span></footer>
  <a class="entry-link" aria-label="post link to Spring 심화 - JPA" href="https://withong.github.io/record/2025-04-16-02/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring 심화
    </h2>
  </header>
  <div class="entry-content">
    <p>1. Spring MVC 요청 처리 흐름의 핵심 구조 Spring MVC에서 클라이언트 요청이 들어왔을 때의 내부 처리 흐름
DispatcherServlet이 요청을 받는다. 요청 URI에 맞는 컨트롤러 메서드를 찾기 위해 HandlerMapping이 사용된다. 해당 컨트롤러를 실행하기 위해 HandlerAdapter 중 하나인 RequestMappingHandlerAdapter가 선택된다. RequestMappingHandlerAdapter는 컨트롤러 메서드의 파라미터를 채우기 위해 ArgumentResolver를, 반환값을 처리하기 위해 ReturnValueHandler를 사용한다. 이 과정에서 요청 본문 또는 응답 본문을 처리하기 위해 HttpMessageConverter가 사용된다. 2. HttpMessageConverter 정의 HttpMessageConverter는 HTTP 요청 본문을 자바 객체로 변환하거나, 자바 객체를 HTTP 응답 본문으로 변환하는 인터페이스이다. 주로 @RequestBody, @ResponseBody, HttpEntity, RequestEntity, ResponseEntity 등과 함께 사용되며, 이런 어노테이션이나 객체가 사용된 컨트롤러 메서드는 내부적으로 HttpMessageConverter를 통해 처리된다.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-04-16 15:41:39 +0900 KST'>2025년 4월 16일</span></footer>
  <a class="entry-link" aria-label="post link to Spring 심화" href="https://withong.github.io/record/2025-04-16-01/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring 숙련 2
    </h2>
  </header>
  <div class="entry-content">
    <p> 인증(Authentication)과 인가(Authorization) 용어 의미 예시 인증 사용자가 누군지 확인하는 절차 로그인 (ID, PW 입력 후 사용자 확인) 인가 인증된 사용자가 무엇을 할 수 있는지 확인 본인이 쓴 글만 수정 가능, 관리자만 삭제 가능 → 인가는 항상 인증이 먼저 되어야 가능
Cookie 쿠키란? 클라이언트(브라우저)에 저장되는 작은 데이터 서버는 Set-Cookie라는 응답 헤더로 쿠키를 전달 이후 클라이언트는 모든 요청에 Cookie 값을 함께 보냄 왜 필요할까? HTTP는 기본적으로 Stateless(상태를 기억하지 않음) 이라서
서버는 사용자가 누군지 매 요청마다 모르게 됨.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-28 20:28:44 +0900 KST'>2025년 3월 28일</span></footer>
  <a class="entry-link" aria-label="post link to Spring 숙련 2" href="https://withong.github.io/record/2025-03-28/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring 숙련 1
    </h2>
  </header>
  <div class="entry-content">
    <p> 1. Spring Container &amp; Bean 1.1. Spring Container Spring 애플리케이션에서 객체(Bean)를 생성, 관리, 소멸하는 역할을 담당함.
설정 파일이나 Annotation을 읽어 Bean을 생성하고 주입하는 과정을 컨트롤함. Java에서는 개발자가 객체를 직접 생성하지만, Spring에서는 Container가 관리함. Spring Container의 역할
Bean 생성, 관리, 의존성 주입을 담당함. 객체 간 결합도를 낮추어 OCP, DIP 원칙을 지킬 수 있음. Spring Container의 종류
BeanFactory: Spring Container의 최상위 인터페이스 ApplicationContext: BeanFactory를 확장하여 다양한 기능 제공 (국제화, 환경변수, 이벤트, 리소스 조회 등) 실무에서는 ApplicationContext를 주로 사용함 → 보통 이것을 Spring Container라고 부름 1.2. Spring Bean Spring Container가 관리하는 객체를 의미함.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-27 20:25:30 +0900 KST'>2025년 3월 27일</span></footer>
  <a class="entry-link" aria-label="post link to Spring 숙련 1" href="https://withong.github.io/record/2025-03-27-02/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring 기초 4
    </h2>
  </header>
  <div class="entry-content">
    <p> Slf4j 인터페이스이며, Logback 같은 구현체를 사용할 수 있음.
Spring Boot는 기본적으로 Logback을 제공.
System.out.println() 대신 로깅 라이브러리를 사용.
Log Level: TRACE → DEBUG → INFO → WARN → ERROR
@Slf4j @RestController public class Slf4jController { @RequestMapping(&#34;/logging&#34;) public String logging() { String sparta = &#34;Sparta&#34;; log.info(&#34;문자 info={}&#34;, sparta); return &#34;success&#34;; } } Controller vs RestController @Controller: View 반환 (Thymeleaf, JSP 사용) @Controller public class ViewController { @RequestMapping(&#34;/view&#34;) public String example() { return &#34;sparta&#34;; // View Name 반환 } } @RestController: Data 반환 (REST API) @RestController public class ResponseController { @RequestMapping(&#34;/string&#34;) public String example() { return &#34;sparta&#34;; // HTTP Body에 Data 입력 } } Annotation @Component: Spring Bean 등록하는 역할을 수행. @Target: 애노테이션 적용 범위를 지정. @Retention: 유지 기간을 결정. (SOURCE, CLASS, RUNTIME) @Documented: 문서화 도구에 의해 문서화되도록 지정. RequestMapping 특정 URL 요청을 특정 메서드와 매핑함. 여러 요소(URL, HTTP Method 등)를 조합하여 매핑할 수 있음. Spring Boot 3.0부터 /example/ 대신 /example만 허용됨. @RestController public class RequestMappingController { @RequestMapping(value = &#34;/v1&#34;, method = RequestMethod.GET) public String exampleV1() { return &#34;this is sparta!&#34;; } @GetMapping(value = &#34;/v2&#34;) public String exampleV2() { return &#34;this is sparta!&#34;; } } PathVariable URL 값을 파라미터로 받아오는 방식. @GetMapping(&#34;/{postId}&#34;) public String pathVariable(@PathVariable Long postId) { return &#34;Post ID: &#34; &#43; postId; } @GetMapping(&#34;/{postId}/comments/{commentId}&#34;) public String pathVariableMulti(@PathVariable Long postId, @PathVariable Long commentId) { return &#34;Post ID: &#34; &#43; postId &#43; &#34;, Comment ID: &#34; &#43; commentId; } 특정 파라미터 매핑 Query Parameter 매핑 @GetMapping(value = &#34;/users&#34;, params = &#34;gender=man&#34;) public String params() { return &#34;params API 호출됨&#34;; } Header 매핑 @PostMapping(value = &#34;/users&#34;, headers = &#34;Content-Type=application/json&#34;) public String headers() { return &#34;headers API 호출됨&#34;; } MediaType 매핑 @PostMapping(value = &#34;/users&#34;, consumes = MediaType.APPLICATION_JSON_VALUE) public String consumes() { return &#34;consumes API 호출됨&#34;; } produces 속성을 이용해 특정 응답 타입을 지정할 수 있음. Spring이 지원하는 Parameter 요청 헤더 조회 @Slf4j @RestController public class RequestHeaderController { @GetMapping(&#34;/request/headers&#34;) public String headers(@RequestHeader(&#34;host&#34;) String host) { log.info(&#34;host={}&#34;, host); return &#34;success&#34;; } } MultiValueMap 여러 개의 값을 받을 때 사용 MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;(); map.add(&#34;key1&#34;, &#34;value1&#34;); map.add(&#34;key1&#34;, &#34;value2&#34;); </p>
  </div>
  <footer class="entry-footer"><span title='2025-03-19 21:54:12 +0900 KST'>2025년 3월 19일</span></footer>
  <a class="entry-link" aria-label="post link to Spring 기초 4" href="https://withong.github.io/record/2025-03-19/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring 기초 3
    </h2>
  </header>
  <div class="entry-content">
    <p> 1. MVC 패턴 Template Engine (템플릿 엔진) 동적인 웹 페이지를 생성하는 도구 HTML과 데이터를 결합해 서버에서 페이지를 렌더링함 대표적인 템플릿 엔진 Thymeleaf → Spring과 통합이 잘 되어 가장 많이 사용됨 JSP (Java Server Pages) → 예전에는 많이 사용했으나 현재는 거의 사용되지 않음 FreeMarker, Velocity, Mustache → 특정 환경에서 사용됨 과거에는 Java 코드로 직접 HTML을 생성했으나, 유지보수가 어려워서 HTML에 필요한 부분만 Java 코드로 처리하도록 발전함
MVC 패턴 개요 원래 Servlet과 JSP만으로 웹 개발을 했으나, 비즈니스 로직과 UI가 한 파일에 섞이면서 유지보수가 어려워짐 MVC (Model-View-Controller) 패턴은 역할을 분리하여 코드의 유지보수를 쉽게 하기 위해 등장함 MVC 패턴 구조 컴포넌트 설명 Model 데이터를 저장하고 처리하는 역할 (비즈니스 로직) View 사용자에게 보여주는 UI (HTML, 템플릿 엔진) Controller 사용자의 요청을 받아 Model과 View를 연결 View가 변경되어도 Model(비즈니스 로직)에 영향을 주지 않도록 분리 Model이 변경되어도 View를 수정할 필요가 없음 MVC 패턴의 문제점 중복 코드 발생 dispatcher.forward(request, response) 호출이 중복됨 View의 경로 (/WEB-INF/views/...jsp)가 코드 곳곳에 하드코딩되어 변경이 어렵다 공통 기능이 많아질수록 Controller의 역할이 커짐 로깅, 인증, 인가 등의 기능이 모든 Controller에 중복 작성됨 → 프론트 컨트롤러 패턴
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-18 18:00:16 +0900 KST'>2025년 3월 18일</span></footer>
  <a class="entry-link" aria-label="post link to Spring 기초 3" href="https://withong.github.io/record/2025-03-18-02/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://withong.github.io/tag/spring/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://withong.github.io/">withong</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
