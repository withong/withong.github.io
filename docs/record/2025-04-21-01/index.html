<!DOCTYPE html>
<html lang="ko" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Spring AOP와 프록시 | withong</title>
<meta name="keywords" content="">
<meta name="description" content="

1. AOP란?
AOP는 Aspect-Oriented Programming(관점 지향 프로그래밍) 의 약자로,
공통된 관심사를 핵심 비즈니스 로직과 분리하여 모듈화하는 프로그래밍 패러다임이다.
1.1 공통 관심사란?
애플리케이션 전반에 걸쳐 반복되지만 핵심 로직과 직접적인 관련은 없는 기능을 말한다.

로깅
트랜잭션 처리
보안 권한 검사
예외 로깅
실행 시간 측정

이러한 로직을 모든 메서드마다 직접 작성하면 코드 중복과 유지보수 비용이 증가하게 된다.
AOP는 이 문제를 해결하기 위해 공통 기능을 하나의 모듈로 분리하고,
weaving(위빙) 과정을 통해 실행 흐름에 자동으로 삽입하는 구조를 제공한다.">
<meta name="author" content="">
<link rel="canonical" href="https://withong.github.io/record/2025-04-21-01/">
<link crossorigin="anonymous" href="https://withong.github.io/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://withong.github.io/icons/rec.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://withong.github.io/icons/rec.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://withong.github.io/icons/rec.png">
<link rel="apple-touch-icon" href="https://withong.github.io/icons/rec.png">
<link rel="mask-icon" href="https://withong.github.io/icons/rec.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="https://withong.github.io/record/2025-04-21-01/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://withong.github.io/record/2025-04-21-01/">
  <meta property="og:site_name" content="withong">
  <meta property="og:title" content="Spring AOP와 프록시">
  <meta property="og:description" content="1. AOP란? AOP는 Aspect-Oriented Programming(관점 지향 프로그래밍) 의 약자로,
공통된 관심사를 핵심 비즈니스 로직과 분리하여 모듈화하는 프로그래밍 패러다임이다.
1.1 공통 관심사란? 애플리케이션 전반에 걸쳐 반복되지만 핵심 로직과 직접적인 관련은 없는 기능을 말한다.
로깅 트랜잭션 처리 보안 권한 검사 예외 로깅 실행 시간 측정 이러한 로직을 모든 메서드마다 직접 작성하면 코드 중복과 유지보수 비용이 증가하게 된다.
AOP는 이 문제를 해결하기 위해 공통 기능을 하나의 모듈로 분리하고,
weaving(위빙) 과정을 통해 실행 흐름에 자동으로 삽입하는 구조를 제공한다.">
  <meta property="og:locale" content="ko">
  <meta property="og:type" content="article">
    <meta property="article:section" content="record">
    <meta property="article:published_time" content="2025-04-21T12:46:19+09:00">
    <meta property="article:modified_time" content="2025-04-21T12:46:19+09:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring AOP와 프록시">
<meta name="twitter:description" content="

1. AOP란?
AOP는 Aspect-Oriented Programming(관점 지향 프로그래밍) 의 약자로,
공통된 관심사를 핵심 비즈니스 로직과 분리하여 모듈화하는 프로그래밍 패러다임이다.
1.1 공통 관심사란?
애플리케이션 전반에 걸쳐 반복되지만 핵심 로직과 직접적인 관련은 없는 기능을 말한다.

로깅
트랜잭션 처리
보안 권한 검사
예외 로깅
실행 시간 측정

이러한 로직을 모든 메서드마다 직접 작성하면 코드 중복과 유지보수 비용이 증가하게 된다.
AOP는 이 문제를 해결하기 위해 공통 기능을 하나의 모듈로 분리하고,
weaving(위빙) 과정을 통해 실행 흐름에 자동으로 삽입하는 구조를 제공한다.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Study Records",
      "item": "https://withong.github.io/record/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Spring AOP와 프록시",
      "item": "https://withong.github.io/record/2025-04-21-01/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Spring AOP와 프록시",
  "name": "Spring AOP와 프록시",
  "description": "\r1. AOP란? AOP는 Aspect-Oriented Programming(관점 지향 프로그래밍) 의 약자로,\n공통된 관심사를 핵심 비즈니스 로직과 분리하여 모듈화하는 프로그래밍 패러다임이다.\n1.1 공통 관심사란? 애플리케이션 전반에 걸쳐 반복되지만 핵심 로직과 직접적인 관련은 없는 기능을 말한다.\n로깅 트랜잭션 처리 보안 권한 검사 예외 로깅 실행 시간 측정 이러한 로직을 모든 메서드마다 직접 작성하면 코드 중복과 유지보수 비용이 증가하게 된다.\nAOP는 이 문제를 해결하기 위해 공통 기능을 하나의 모듈로 분리하고,\nweaving(위빙) 과정을 통해 실행 흐름에 자동으로 삽입하는 구조를 제공한다.\n",
  "keywords": [
    
  ],
  "articleBody": "\r1. AOP란? AOP는 Aspect-Oriented Programming(관점 지향 프로그래밍) 의 약자로,\n공통된 관심사를 핵심 비즈니스 로직과 분리하여 모듈화하는 프로그래밍 패러다임이다.\n1.1 공통 관심사란? 애플리케이션 전반에 걸쳐 반복되지만 핵심 로직과 직접적인 관련은 없는 기능을 말한다.\n로깅 트랜잭션 처리 보안 권한 검사 예외 로깅 실행 시간 측정 이러한 로직을 모든 메서드마다 직접 작성하면 코드 중복과 유지보수 비용이 증가하게 된다.\nAOP는 이 문제를 해결하기 위해 공통 기능을 하나의 모듈로 분리하고,\nweaving(위빙) 과정을 통해 실행 흐름에 자동으로 삽입하는 구조를 제공한다.\n2. AOP 주요 용어 용어 설명 Aspect 공통 관심사를 모듈화한 클래스 Join Point Aspect를 적용할 수 있는 지점 (Spring AOP에서는 메서드 실행만 지원) Advice 실제 실행될 코드 (공통 로직). 메서드 실행 시점에 따라 정의됨 (@Before, @After 등) Pointcut Advice가 적용될 Join Point를 지정하는 표현식 Weaving Advice를 실제 실행 흐름에 삽입하는 과정 Target Object 공통 로직이 적용될 실제 비즈니스 객체 Proxy Object Spring이 생성한 프록시 객체. 실제 객체를 감싸고 외부 요청을 가로챔 3. Spring AOP의 핵심: 프록시 3.1 프록시란? 프록시는 어떤 객체에 대한 대리 객체(proxy object) 로,\n외부 호출을 대신 받아 내부에서 부가적인 처리를 하거나 실제 객체로 요청을 위임할 수 있는 구조이다.\nSpring AOP에서는 이 프록시 개념을 코드로 구현하여,\n핵심 객체 앞에 프록시 객체를 두고 메서드 호출을 가로챔으로써 공통 로직을 주입한다.\n3.2 프록시 객체란? 프록시 객체는 Spring이 런타임에 동적으로 생성하는 대리 객체 인스턴스다.\n외부에서는 이 프록시 객체를 통해 메서드를 호출하게 되며,\n프록시는 내부의 실제 객체(Target Object)를 호출하기 전에 공통 로직을 실행하거나, 실행 자체를 제어할 수도 있다.\n정확히는, Spring이 먼저 실제 객체 인스턴스를 생성한 뒤\n해당 인스턴스를 감싸는 프록시 객체를 만들어 ApplicationContext에 Bean으로 등록한다.\n이후 외부에서 해당 Bean을 주입받거나 호출할 때는 항상 이 프록시를 통해 접근하게 된다.\n또한 Spring은 AnnotationAwareAspectJAutoProxyCreator 라는 내부 Bean 후처리기를 통해\nBean 초기화 시점에 Aspect가 적용될 대상인지 판단하고,\n필요한 경우 프록시를 생성해 등록한다.\n3.3 프록시 생성 방식 방식 사용 조건 설명 JDK 동적 프록시 대상 클래스가 인터페이스를 구현한 경우 java.lang.reflect.Proxy 사용. 인터페이스 기반 CGLIB 프록시 인터페이스가 없거나 클래스 기반일 경우 런타임에 상속 기반 클래스를 생성. Spring 내부적으로 CGLIB 사용 Spring은 기본적으로 인터페이스가 존재하면 JDK 동적 프록시를 사용하고,\n그렇지 않으면 CGLIB 프록시를 사용한다.\n단, @EnableAspectJAutoProxy(proxyTargetClass = true) 설정 시에는\n인터페이스 유무와 관계없이 CGLIB 방식을 사용한다.\n4. 실제 AOP 적용 흐름 @Service public class PaymentService { @Transactional public void pay() { System.out.println(\"결제 처리 중...\"); } } Spring은 위 클래스에서 @Transactional 어노테이션을 감지하면\n트랜잭션 처리 기능이 포함된 프록시 객체를 생성한다.\n그리고 이 프록시 객체가 ApplicationContext에 Bean으로 등록되어 사용된다.\n이 과정은 Bean 생성 이후 postProcessAfterInitialization() 단계에서 수행되며,\n해당 Bean이 Aspect의 Pointcut에 해당하면 프록시로 감싸 교체한다.\n실제 호출 흐름: 호출자가 paymentService.pay() 호출 프록시 객체가 호출을 먼저 받음 트랜잭션 시작 코드 실행 (Advice) 실제 객체의 pay() 메서드 호출 트랜잭션 커밋 또는 롤백 처리 결과 반환 즉, 프록시가 메서드 호출을 가로채서, 공통 로직을 수행한 다음\n실제 메서드를 호출하는 구조로 동작한다.\n5. Advice 종류와 예시 Spring AOP에서는 공통 로직을 담는 방법으로 Advice를 사용한다.\nAdvice는 Join Point의 실행 시점을 기준으로 여러 종류로 나뉜다.\n종류 설명 실행 시점 @Before 메서드 실행 전에 수행됨 핵심 로직 호출 전 @AfterReturning 메서드가 정상적으로 리턴된 경우 예외 없이 종료된 후 @AfterThrowing 메서드 실행 중 예외가 발생한 경우 예외 발생 후 @After 메서드 종료 후 항상 실행 예외 여부 무관 @Around 메서드 실행 전후로 모두 수행됨 전체를 감쌈. proceed() 호출 필수 @Around는 가장 강력한 Advice로,\n다른 모든 Advice를 감쌀 수 있으며, 실제 메서드 실행 자체를 제어할 수 있다.\njoinPoint.proceed()를 호출하지 않으면 메서드는 실행되지 않는다.\n@Aspect @Component public class LoggingAspect { @Before(\"execution(* com.example.service.*.*(..))\") public void beforeLog(JoinPoint joinPoint) { System.out.println(\"메서드 실행 전: \" + joinPoint.getSignature().getName()); } @AfterReturning(\"execution(* com.example.service.*.*(..))\") public void afterLog(JoinPoint joinPoint) { System.out.println(\"메서드 정상 종료 후: \" + joinPoint.getSignature().getName()); } @Around(\"execution(* com.example.service.*.*(..))\") public Object aroundLog(ProceedingJoinPoint joinPoint) throws Throwable { long start = System.currentTimeMillis(); Object result = joinPoint.proceed(); // 실제 메서드 실행 long end = System.currentTimeMillis(); System.out.println(\"수행 시간: \" + (end - start) + \"ms\"); return result; } } 6. Pointcut 표현식 6.1 execution 메서드 실행 지점을 지정하는 가장 기본적인 표현식\nexecution(* com.example.service.MemberService.*(..)) * : 반환 타입 상관없음 com.example.service.MemberService : 대상 클래스 * : 모든 메서드 (..) : 모든 파라미터 예시: MemberService 클래스의 모든 메서드\n6.2 within 특정 클래스 또는 패키지 내부의 모든 메서드를 지정\nwithin(com.example.service.*Service) com.example.service 패키지의 *Service로 끝나는 클래스들의 모든 메서드에 적용 예시: com.example.service.OrderService, UserService 등의 클래스 전체에 적용\n6.3 args 메서드의 파라미터 타입을 기준으로 적용\nargs(java.lang.String) String 하나를 파라미터로 받는 메서드만 적용됨 예시: public void hello(String name) 같은 메서드\n6.4 this / target 프록시 객체 또는 실제 대상 객체의 타입을 기준으로 지정\nthis(com.example.service.MemberService) target(com.example.service.MemberService) this: 프록시 객체의 타입 기준 target: 실제 대상 객체의 타입 기준 예시: 스프링 AOP 프록시 기반에서 타입에 따라 달라지는 경우에 사용\n6.5 @annotation 특정 어노테이션이 붙은 메서드에만 적용\n@annotation(com.example.annotation.LogExecutionTime) 예시: @LogExecutionTime 어노테이션이 붙은 메서드에만 AOP 적용\n6.6 @within 클래스에 어노테이션이 붙은 경우, 그 클래스의 모든 메서드에 적용\n@within(com.example.annotation.MyAspect) 예시: @MyAspect 어노테이션이 붙은 클래스 내부의 모든 메서드\n6.7 @target 실제 런타임 객체에 어노테이션이 붙어 있는 경우 적용\n@target(com.example.annotation.MyAspect) 프록시와 관련된 동작 방식에 따라 @within과는 다르게 작동할 수 있음\n6.8 @args 파라미터 타입에 어노테이션이 붙어 있을 경우 적용\n@args(com.example.annotation.Sensitive) 예시: @Sensitive 어노테이션이 붙은 객체를 파라미터로 받는 메서드\n6.9 논리 연산자 조합 Pointcut 표현식은 논리 연산자를 통해 조합할 수 있음\n\u0026\u0026 : 그리고 || : 또는 ! : 부정 execution(* com.example..*Service.*(..)) \u0026\u0026 @annotation(com.example.annotation.LogExecutionTime) 예시: Service 클래스이면서 @LogExecutionTime 어노테이션이 붙은 메서드만 적용\n7. 주의할 점 7.1 같은 클래스 내부에서 메서드 호출 시 AOP 미적용 Spring AOP는 프록시 객체를 통해 메서드를 호출할 때만 동작한다.\n하지만 같은 클래스 내에서 this.method() 방식으로 호출하면\n프록시 객체를 거치지 않고 자기 자신을 직접 호출하게 되므로 AOP가 적용되지 않는다.\n이런 현상을 자기 호출(Self-Invocation) 문제라고 한다.\npublic class ExampleService { public void outer() { inner(); // AOP 미적용 } @Transactional public void inner() { } } 이런 경우에는 inner()를 다른 Bean으로 분리하거나,\nAOP가 적용되도록 구조를 변경해야 한다.\n7.2 private/final 메서드에는 AOP 적용 불가 AOP는 프록시 객체를 통해 메서드를 호출하는 구조이기 때문에\nprivate 메서드는 프록시가 접근할 수 없어 Join Point가 될 수 없다. CGLIB 프록시는 클래스 상속 방식으로 프록시를 생성하므로,\nfinal 키워드가 붙은 클래스나 메서드는 오버라이딩이 불가능해 AOP 적용이 불가하다. 정리 Spring AOP는 관점 지향 프로그래밍을 통해\n공통 관심사를 분리하고 핵심 로직을 깔끔하게 유지할 수 있도록 도와준다.\n핵심 개념은 프록시를 통한 호출 제어이며,\nAdvice와 Pointcut을 이용해 공통 로직을 실행 흐름에 삽입할 수 있다.\n다만, Spring AOP는 프록시 기반으로 동작하기 때문에\nprivate/final 메서드, 내부 호출(Self-Invocation), 인터페이스 기반 여부 등에서\n적용 제약이 존재한다. 이러한 원리를 이해하고 구조를 설계하는 것이 중요하다.\n",
  "wordCount" : "1011",
  "inLanguage": "ko",
  "datePublished": "2025-04-21T12:46:19+09:00",
  "dateModified": "2025-04-21T12:46:19+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://withong.github.io/record/2025-04-21-01/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "withong",
    "logo": {
      "@type": "ImageObject",
      "url": "https://withong.github.io/icons/rec.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://withong.github.io/" accesskey="h" title="withong (Alt + H)">withong</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://withong.github.io/log/" title="Log">
                    <span>Log</span>
                </a>
            </li>
            <li>
                <a href="https://withong.github.io/record/" title="Record">
                    <span>Record</span>
                </a>
            </li>
            <li>
                <a href="https://withong.github.io/project/" title="Project">
                    <span>Project</span>
                </a>
            </li>
            <li>
                <a href="https://withong.github.io/tag/" title="Tag">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://withong.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://withong.github.io/">Log</a>&nbsp;»&nbsp;<a href="https://withong.github.io/record/">Study Records</a></div>
    <h1 class="post-title entry-hint-parent">
      Spring AOP와 프록시
    </h1>
    <div class="post-meta"><span title='2025-04-21 12:46:19 +0900 KST'>2025년 4월 21일</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">목차</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-aop란">1. AOP란?</a>
      <ul>
        <li><a href="#11-공통-관심사란">1.1 공통 관심사란?</a></li>
      </ul>
    </li>
    <li><a href="#2-aop-주요-용어">2. AOP 주요 용어</a></li>
    <li><a href="#3-spring-aop의-핵심-프록시">3. Spring AOP의 핵심: 프록시</a>
      <ul>
        <li><a href="#31-프록시란">3.1 프록시란?</a></li>
        <li><a href="#32-프록시-객체란">3.2 프록시 객체란?</a></li>
        <li><a href="#33-프록시-생성-방식">3.3 프록시 생성 방식</a></li>
      </ul>
    </li>
    <li><a href="#4-실제-aop-적용-흐름">4. 실제 AOP 적용 흐름</a>
      <ul>
        <li><a href="#실제-호출-흐름">실제 호출 흐름:</a></li>
      </ul>
    </li>
    <li><a href="#5-advice-종류와-예시">5. Advice 종류와 예시</a></li>
    <li><a href="#6-pointcut-표현식">6. Pointcut 표현식</a>
      <ul>
        <li><a href="#61-execution">6.1 <code>execution</code></a></li>
        <li><a href="#62-within">6.2 <code>within</code></a></li>
        <li><a href="#63-args">6.3 <code>args</code></a></li>
        <li><a href="#64-this--target">6.4 <code>this</code> / <code>target</code></a></li>
        <li><a href="#65-annotation">6.5 <code>@annotation</code></a></li>
        <li><a href="#66-within">6.6 <code>@within</code></a></li>
        <li><a href="#67-target">6.7 <code>@target</code></a></li>
        <li><a href="#68-args">6.8 <code>@args</code></a></li>
        <li><a href="#69-논리-연산자-조합">6.9 논리 연산자 조합</a></li>
      </ul>
    </li>
    <li><a href="#7-주의할-점">7. 주의할 점</a>
      <ul>
        <li><a href="#71-같은-클래스-내부에서-메서드-호출-시-aop-미적용">7.1 같은 클래스 내부에서 메서드 호출 시 AOP 미적용</a></li>
        <li><a href="#72-privatefinal-메서드에는-aop-적용-불가">7.2 private/final 메서드에는 AOP 적용 불가</a></li>
      </ul>
    </li>
    <li><a href="#정리">정리</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><hr>
<br>
<h2 id="1-aop란">1. AOP란?<a hidden class="anchor" aria-hidden="true" href="#1-aop란">#</a></h2>
<p>AOP는 <strong>Aspect-Oriented Programming(관점 지향 프로그래밍)</strong> 의 약자로,<br>
공통된 관심사를 핵심 비즈니스 로직과 <strong>분리하여 모듈화</strong>하는 프로그래밍 패러다임이다.</p>
<h3 id="11-공통-관심사란">1.1 공통 관심사란?<a hidden class="anchor" aria-hidden="true" href="#11-공통-관심사란">#</a></h3>
<p>애플리케이션 전반에 걸쳐 반복되지만 핵심 로직과 직접적인 관련은 없는 기능을 말한다.</p>
<ul>
<li>로깅</li>
<li>트랜잭션 처리</li>
<li>보안 권한 검사</li>
<li>예외 로깅</li>
<li>실행 시간 측정</li>
</ul>
<p>이러한 로직을 모든 메서드마다 직접 작성하면 코드 중복과 유지보수 비용이 증가하게 된다.<br>
AOP는 이 문제를 해결하기 위해 공통 기능을 하나의 모듈로 분리하고,<br>
<strong>weaving(위빙) 과정을 통해 실행 흐름에 자동으로 삽입</strong>하는 구조를 제공한다.</p>
<br>
<h2 id="2-aop-주요-용어">2. AOP 주요 용어<a hidden class="anchor" aria-hidden="true" href="#2-aop-주요-용어">#</a></h2>
<table>
  <thead>
      <tr>
          <th>용어</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Aspect</strong></td>
          <td>공통 관심사를 모듈화한 클래스</td>
      </tr>
      <tr>
          <td><strong>Join Point</strong></td>
          <td>Aspect를 적용할 수 있는 지점 (Spring AOP에서는 메서드 실행만 지원)</td>
      </tr>
      <tr>
          <td><strong>Advice</strong></td>
          <td>실제 실행될 코드 (공통 로직). 메서드 실행 시점에 따라 정의됨 (<code>@Before</code>, <code>@After</code> 등)</td>
      </tr>
      <tr>
          <td><strong>Pointcut</strong></td>
          <td>Advice가 적용될 Join Point를 지정하는 표현식</td>
      </tr>
      <tr>
          <td><strong>Weaving</strong></td>
          <td>Advice를 실제 실행 흐름에 삽입하는 과정</td>
      </tr>
      <tr>
          <td><strong>Target Object</strong></td>
          <td>공통 로직이 적용될 실제 비즈니스 객체</td>
      </tr>
      <tr>
          <td><strong>Proxy Object</strong></td>
          <td>Spring이 생성한 프록시 객체. 실제 객체를 감싸고 외부 요청을 가로챔</td>
      </tr>
  </tbody>
</table>
<br>
<h2 id="3-spring-aop의-핵심-프록시">3. Spring AOP의 핵심: 프록시<a hidden class="anchor" aria-hidden="true" href="#3-spring-aop의-핵심-프록시">#</a></h2>
<h3 id="31-프록시란">3.1 프록시란?<a hidden class="anchor" aria-hidden="true" href="#31-프록시란">#</a></h3>
<p>프록시는 <strong>어떤 객체에 대한 대리 객체(proxy object)</strong> 로,<br>
외부 호출을 대신 받아 내부에서 부가적인 처리를 하거나 실제 객체로 요청을 위임할 수 있는 구조이다.</p>
<p>Spring AOP에서는 이 프록시 개념을 코드로 구현하여,<br>
핵심 객체 앞에 프록시 객체를 두고 메서드 호출을 가로챔으로써 공통 로직을 주입한다.</p>
<h3 id="32-프록시-객체란">3.2 프록시 객체란?<a hidden class="anchor" aria-hidden="true" href="#32-프록시-객체란">#</a></h3>
<p>프록시 객체는 <strong>Spring이 런타임에 동적으로 생성하는 대리 객체 인스턴스</strong>다.<br>
외부에서는 이 프록시 객체를 통해 메서드를 호출하게 되며,<br>
프록시는 내부의 실제 객체(Target Object)를 호출하기 전에 공통 로직을 실행하거나, 실행 자체를 제어할 수도 있다.</p>
<blockquote>
<p>정확히는, Spring이 먼저 실제 객체 인스턴스를 생성한 뒤<br>
해당 인스턴스를 감싸는 프록시 객체를 만들어 <strong>ApplicationContext에 Bean으로 등록</strong>한다.<br>
이후 외부에서 해당 Bean을 주입받거나 호출할 때는 항상 이 프록시를 통해 접근하게 된다.</p></blockquote>
<p>또한 Spring은 <strong><code>AnnotationAwareAspectJAutoProxyCreator</code></strong> 라는 내부 Bean 후처리기를 통해<br>
Bean 초기화 시점에 Aspect가 적용될 대상인지 판단하고,<br>
필요한 경우 프록시를 생성해 등록한다.</p>
<h3 id="33-프록시-생성-방식">3.3 프록시 생성 방식<a hidden class="anchor" aria-hidden="true" href="#33-프록시-생성-방식">#</a></h3>
<table>
  <thead>
      <tr>
          <th>방식</th>
          <th>사용 조건</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>JDK 동적 프록시</td>
          <td>대상 클래스가 인터페이스를 구현한 경우</td>
          <td><code>java.lang.reflect.Proxy</code> 사용. 인터페이스 기반</td>
      </tr>
      <tr>
          <td>CGLIB 프록시</td>
          <td>인터페이스가 없거나 클래스 기반일 경우</td>
          <td>런타임에 상속 기반 클래스를 생성. Spring 내부적으로 CGLIB 사용</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>Spring은 기본적으로 인터페이스가 존재하면 JDK 동적 프록시를 사용하고,<br>
그렇지 않으면 CGLIB 프록시를 사용한다.<br>
단, <code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code> 설정 시에는<br>
인터페이스 유무와 관계없이 CGLIB 방식을 사용한다.</p></blockquote>
<br>
<h2 id="4-실제-aop-적용-흐름">4. 실제 AOP 적용 흐름<a hidden class="anchor" aria-hidden="true" href="#4-실제-aop-적용-흐름">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">PaymentService</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Transactional</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">pay</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;결제 처리 중...&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Spring은 위 클래스에서 <code>@Transactional</code> 어노테이션을 감지하면<br>
트랜잭션 처리 기능이 포함된 <strong>프록시 객체</strong>를 생성한다.<br>
그리고 이 프록시 객체가 <code>ApplicationContext</code>에 Bean으로 등록되어 사용된다.</p>
<blockquote>
<p>이 과정은 Bean 생성 이후 <code>postProcessAfterInitialization()</code> 단계에서 수행되며,<br>
해당 Bean이 Aspect의 Pointcut에 해당하면 프록시로 감싸 교체한다.</p></blockquote>
<h3 id="실제-호출-흐름">실제 호출 흐름:<a hidden class="anchor" aria-hidden="true" href="#실제-호출-흐름">#</a></h3>
<ol>
<li>호출자가 <code>paymentService.pay()</code> 호출</li>
<li>프록시 객체가 호출을 먼저 받음</li>
<li>트랜잭션 시작 코드 실행 (Advice)</li>
<li>실제 객체의 <code>pay()</code> 메서드 호출</li>
<li>트랜잭션 커밋 또는 롤백 처리</li>
<li>결과 반환</li>
</ol>
<p>즉, <strong>프록시가 메서드 호출을 가로채서</strong>, 공통 로직을 수행한 다음<br>
<strong>실제 메서드를 호출</strong>하는 구조로 동작한다.</p>
<br>
<h2 id="5-advice-종류와-예시">5. Advice 종류와 예시<a hidden class="anchor" aria-hidden="true" href="#5-advice-종류와-예시">#</a></h2>
<p>Spring AOP에서는 공통 로직을 담는 방법으로 <code>Advice</code>를 사용한다.<br>
Advice는 Join Point의 실행 시점을 기준으로 여러 종류로 나뉜다.</p>
<table>
  <thead>
      <tr>
          <th>종류</th>
          <th>설명</th>
          <th>실행 시점</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>@Before</code></td>
          <td>메서드 실행 전에 수행됨</td>
          <td>핵심 로직 호출 전</td>
      </tr>
      <tr>
          <td><code>@AfterReturning</code></td>
          <td>메서드가 정상적으로 리턴된 경우</td>
          <td>예외 없이 종료된 후</td>
      </tr>
      <tr>
          <td><code>@AfterThrowing</code></td>
          <td>메서드 실행 중 예외가 발생한 경우</td>
          <td>예외 발생 후</td>
      </tr>
      <tr>
          <td><code>@After</code></td>
          <td>메서드 종료 후 항상 실행</td>
          <td>예외 여부 무관</td>
      </tr>
      <tr>
          <td><code>@Around</code></td>
          <td>메서드 실행 전후로 모두 수행됨</td>
          <td>전체를 감쌈. <code>proceed()</code> 호출 필수</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p><code>@Around</code>는 가장 강력한 Advice로,<br>
다른 모든 Advice를 감쌀 수 있으며, <strong>실제 메서드 실행 자체를 제어</strong>할 수 있다.<br>
<code>joinPoint.proceed()</code>를 호출하지 않으면 메서드는 실행되지 않는다.</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Aspect</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">LoggingAspect</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Before</span><span class="p">(</span><span class="s">&#34;execution(* com.example.service.*.*(..))&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">beforeLog</span><span class="p">(</span><span class="n">JoinPoint</span><span class="w"> </span><span class="n">joinPoint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;메서드 실행 전: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">joinPoint</span><span class="p">.</span><span class="na">getSignature</span><span class="p">().</span><span class="na">getName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@AfterReturning</span><span class="p">(</span><span class="s">&#34;execution(* com.example.service.*.*(..))&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">afterLog</span><span class="p">(</span><span class="n">JoinPoint</span><span class="w"> </span><span class="n">joinPoint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;메서드 정상 종료 후: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">joinPoint</span><span class="p">.</span><span class="na">getSignature</span><span class="p">().</span><span class="na">getName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Around</span><span class="p">(</span><span class="s">&#34;execution(* com.example.service.*.*(..))&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">aroundLog</span><span class="p">(</span><span class="n">ProceedingJoinPoint</span><span class="w"> </span><span class="n">joinPoint</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Object</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">joinPoint</span><span class="p">.</span><span class="na">proceed</span><span class="p">();</span><span class="w"> </span><span class="c1">// 실제 메서드 실행</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;수행 시간: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;ms&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><br>
<h2 id="6-pointcut-표현식">6. Pointcut 표현식<a hidden class="anchor" aria-hidden="true" href="#6-pointcut-표현식">#</a></h2>
<h3 id="61-execution">6.1 <code>execution</code><a hidden class="anchor" aria-hidden="true" href="#61-execution">#</a></h3>
<p>메서드 실행 지점을 지정하는 가장 기본적인 표현식</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">execution</span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="n">com</span><span class="p">.</span><span class="na">example</span><span class="p">.</span><span class="na">service</span><span class="p">.</span><span class="na">MemberService</span><span class="p">.</span><span class="o">*</span><span class="p">(..))</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><code>*</code> : 반환 타입 상관없음</li>
<li><code>com.example.service.MemberService</code> : 대상 클래스</li>
<li><code>*</code> : 모든 메서드</li>
<li><code>(..)</code> : 모든 파라미터</li>
</ul>
<p><strong>예시</strong>: <code>MemberService</code> 클래스의 모든 메서드</p>
<br>
<h3 id="62-within">6.2 <code>within</code><a hidden class="anchor" aria-hidden="true" href="#62-within">#</a></h3>
<p>특정 클래스 또는 패키지 내부의 모든 메서드를 지정</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">within</span><span class="p">(</span><span class="n">com</span><span class="p">.</span><span class="na">example</span><span class="p">.</span><span class="na">service</span><span class="p">.</span><span class="o">*</span><span class="n">Service</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><code>com.example.service</code> 패키지의</li>
<li><code>*Service</code>로 끝나는 클래스들의</li>
<li>모든 메서드에 적용</li>
</ul>
<p><strong>예시</strong>: <code>com.example.service.OrderService</code>, <code>UserService</code> 등의 클래스 전체에 적용</p>
<br>
<h3 id="63-args">6.3 <code>args</code><a hidden class="anchor" aria-hidden="true" href="#63-args">#</a></h3>
<p>메서드의 <strong>파라미터 타입</strong>을 기준으로 적용</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">args</span><span class="p">(</span><span class="n">java</span><span class="p">.</span><span class="na">lang</span><span class="p">.</span><span class="na">String</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><code>String</code> 하나를 파라미터로 받는 메서드만 적용됨</li>
</ul>
<p><strong>예시</strong>: <code>public void hello(String name)</code> 같은 메서드</p>
<br>
<h3 id="64-this--target">6.4 <code>this</code> / <code>target</code><a hidden class="anchor" aria-hidden="true" href="#64-this--target">#</a></h3>
<p>프록시 객체 또는 실제 대상 객체의 타입을 기준으로 지정</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">this</span><span class="p">(</span><span class="n">com</span><span class="p">.</span><span class="na">example</span><span class="p">.</span><span class="na">service</span><span class="p">.</span><span class="na">MemberService</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">target</span><span class="p">(</span><span class="n">com</span><span class="p">.</span><span class="na">example</span><span class="p">.</span><span class="na">service</span><span class="p">.</span><span class="na">MemberService</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><code>this</code>: 프록시 객체의 타입 기준</li>
<li><code>target</code>: 실제 대상 객체의 타입 기준</li>
</ul>
<p><strong>예시</strong>: 스프링 AOP 프록시 기반에서 타입에 따라 달라지는 경우에 사용</p>
<br>
<h3 id="65-annotation">6.5 <code>@annotation</code><a hidden class="anchor" aria-hidden="true" href="#65-annotation">#</a></h3>
<p><strong>특정 어노테이션이 붙은 메서드</strong>에만 적용</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@annotation</span><span class="p">(</span><span class="n">com</span><span class="p">.</span><span class="na">example</span><span class="p">.</span><span class="na">annotation</span><span class="p">.</span><span class="na">LogExecutionTime</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p><strong>예시</strong>: <code>@LogExecutionTime</code> 어노테이션이 붙은 메서드에만 AOP 적용</p>
<br>
<h3 id="66-within">6.6 <code>@within</code><a hidden class="anchor" aria-hidden="true" href="#66-within">#</a></h3>
<p><strong>클래스에 어노테이션이 붙은 경우</strong>, 그 클래스의 모든 메서드에 적용</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@within</span><span class="p">(</span><span class="n">com</span><span class="p">.</span><span class="na">example</span><span class="p">.</span><span class="na">annotation</span><span class="p">.</span><span class="na">MyAspect</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p><strong>예시</strong>: <code>@MyAspect</code> 어노테이션이 붙은 클래스 내부의 모든 메서드</p>
<br>
<h3 id="67-target">6.7 <code>@target</code><a hidden class="anchor" aria-hidden="true" href="#67-target">#</a></h3>
<p>실제 런타임 객체에 어노테이션이 붙어 있는 경우 적용</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@target</span><span class="p">(</span><span class="n">com</span><span class="p">.</span><span class="na">example</span><span class="p">.</span><span class="na">annotation</span><span class="p">.</span><span class="na">MyAspect</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><blockquote>
<p>프록시와 관련된 동작 방식에 따라 <code>@within</code>과는 다르게 작동할 수 있음</p></blockquote>
<br>
<h3 id="68-args">6.8 <code>@args</code><a hidden class="anchor" aria-hidden="true" href="#68-args">#</a></h3>
<p><strong>파라미터 타입에 어노테이션이 붙어 있을 경우</strong> 적용</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@args</span><span class="p">(</span><span class="n">com</span><span class="p">.</span><span class="na">example</span><span class="p">.</span><span class="na">annotation</span><span class="p">.</span><span class="na">Sensitive</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p><strong>예시</strong>: <code>@Sensitive</code> 어노테이션이 붙은 객체를 파라미터로 받는 메서드</p>
<br>
<h3 id="69-논리-연산자-조합">6.9 논리 연산자 조합<a hidden class="anchor" aria-hidden="true" href="#69-논리-연산자-조합">#</a></h3>
<p>Pointcut 표현식은 <strong>논리 연산자</strong>를 통해 조합할 수 있음</p>
<ul>
<li><code>&amp;&amp;</code> : 그리고</li>
<li><code>||</code> : 또는</li>
<li><code>!</code> : 부정</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">execution</span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="n">com</span><span class="p">.</span><span class="na">example</span><span class="p">..</span><span class="o">*</span><span class="n">Service</span><span class="p">.</span><span class="o">*</span><span class="p">(..))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nd">@annotation</span><span class="p">(</span><span class="n">com</span><span class="p">.</span><span class="na">example</span><span class="p">.</span><span class="na">annotation</span><span class="p">.</span><span class="na">LogExecutionTime</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p><strong>예시</strong>: <code>Service</code> 클래스이면서 <code>@LogExecutionTime</code> 어노테이션이 붙은 메서드만 적용</p>
<br>
<h2 id="7-주의할-점">7. 주의할 점<a hidden class="anchor" aria-hidden="true" href="#7-주의할-점">#</a></h2>
<h3 id="71-같은-클래스-내부에서-메서드-호출-시-aop-미적용">7.1 같은 클래스 내부에서 메서드 호출 시 AOP 미적용<a hidden class="anchor" aria-hidden="true" href="#71-같은-클래스-내부에서-메서드-호출-시-aop-미적용">#</a></h3>
<p>Spring AOP는 프록시 객체를 통해 메서드를 호출할 때만 동작한다.<br>
하지만 같은 클래스 내에서 <code>this.method()</code> 방식으로 호출하면<br>
프록시 객체를 거치지 않고 <strong>자기 자신을 직접 호출하게 되므로 AOP가 적용되지 않는다.</strong><br>
이런 현상을 <strong>자기 호출(Self-Invocation) 문제</strong>라고 한다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ExampleService</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">outer</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">inner</span><span class="p">();</span><span class="w"> </span><span class="c1">// AOP 미적용</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Transactional</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">inner</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>이런 경우에는 <code>inner()</code>를 <strong>다른 Bean으로 분리하거나</strong>,<br>
AOP가 적용되도록 <strong>구조를 변경</strong>해야 한다.</p>
<h3 id="72-privatefinal-메서드에는-aop-적용-불가">7.2 private/final 메서드에는 AOP 적용 불가<a hidden class="anchor" aria-hidden="true" href="#72-privatefinal-메서드에는-aop-적용-불가">#</a></h3>
<ul>
<li>AOP는 프록시 객체를 통해 메서드를 호출하는 구조이기 때문에<br>
<code>private</code> 메서드는 프록시가 접근할 수 없어 Join Point가 될 수 없다.</li>
<li>CGLIB 프록시는 클래스 상속 방식으로 프록시를 생성하므로,<br>
<code>final</code> 키워드가 붙은 클래스나 메서드는 오버라이딩이 불가능해 AOP 적용이 불가하다.</li>
</ul>
<br>
<h2 id="정리">정리<a hidden class="anchor" aria-hidden="true" href="#정리">#</a></h2>
<p>Spring AOP는 관점 지향 프로그래밍을 통해<br>
공통 관심사를 분리하고 핵심 로직을 깔끔하게 유지할 수 있도록 도와준다.<br>
핵심 개념은 <strong>프록시를 통한 호출 제어</strong>이며,<br>
Advice와 Pointcut을 이용해 공통 로직을 실행 흐름에 삽입할 수 있다.</p>
<p>다만, Spring AOP는 <strong>프록시 기반으로 동작</strong>하기 때문에<br>
<strong>private/final 메서드</strong>, <strong>내부 호출(Self-Invocation)</strong>, <strong>인터페이스 기반 여부</strong> 등에서<br>
적용 제약이 존재한다. 이러한 원리를 이해하고 구조를 설계하는 것이 중요하다.</p>
<br>
<hr>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://withong.github.io/record/2025-04-17-02/">
    <span class="title">« Prev</span>
    <br>
    <span>JOIN FETCH vs @EntityGraph</span>
  </a>
  <a class="next" href="https://withong.github.io/record/2025-04-21-02/">
    <span class="title">Next »</span>
    <br>
    <span>Spring Boot 단위 테스트 (JUnit 5 기반)</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://withong.github.io/">withong</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = '✔';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
