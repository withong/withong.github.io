<!DOCTYPE html>
<html lang="ko" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Spring 심화 1 | withong</title>
<meta name="keywords" content="">
<meta name="description" content="
1. Spring Container &amp; Bean
1.1. Spring Container
Spring 애플리케이션에서 객체(Bean)를 생성, 관리, 소멸하는 역할을 담당함.

설정 파일이나 Annotation을 읽어 Bean을 생성하고 주입하는 과정을 컨트롤함.
Java에서는 개발자가 객체를 직접 생성하지만, Spring에서는 Container가 관리함.

Spring Container의 역할

Bean 생성, 관리, 의존성 주입을 담당함.
객체 간 결합도를 낮추어 OCP, DIP 원칙을 지킬 수 있음.

Spring Container의 종류

BeanFactory: Spring Container의 최상위 인터페이스
ApplicationContext: BeanFactory를 확장하여 다양한 기능 제공 (국제화, 환경변수, 이벤트, 리소스 조회 등)
실무에서는 ApplicationContext를 주로 사용함 → 보통 이것을 Spring Container라고 부름

1.2. Spring Bean
Spring Container가 관리하는 객체를 의미함.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/record/2025-03-27-02/">
<link crossorigin="anonymous" href="http://localhost:1313/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/icons/log.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/icons/log.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/icons/log.png">
<link rel="apple-touch-icon" href="http://localhost:1313/icons/log.png">
<link rel="mask-icon" href="http://localhost:1313/icons/log.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/record/2025-03-27-02/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="withong (Alt + H)">withong</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/log/" title="☰">
                    <span>☰</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/record/" title="Record">
                    <span>Record</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/project/" title="Project">
                    <span>Project</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tag/" title="Tag">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/record/">Study Records</a></div>
    <h1 class="post-title entry-hint-parent">
      Spring 심화 1
    </h1>
    <div class="post-meta"><span title='2025-03-27 20:25:30 +0900 KST'>2025년 3월 27일</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">목차</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-spring-container--bean">1. Spring Container &amp; Bean</a>
      <ul>
        <li><a href="#11-spring-container">1.1. Spring Container</a></li>
        <li><a href="#12-spring-bean">1.2. Spring Bean</a></li>
      </ul>
    </li>
    <li><a href="#2-객체-제어-원리-ioc--di">2. 객체 제어 원리 (IOC / DI)</a>
      <ul>
        <li><a href="#21-ioc-inversion-of-control">2.1. IOC (Inversion of Control)</a></li>
        <li><a href="#22-di-dependency-injection">2.2. DI (Dependency Injection)</a></li>
      </ul>
    </li>
    <li><a href="#3-bean-등록-방식">3. Bean 등록 방식</a>
      <ul>
        <li><a href="#31-자동-등록---componentscan">3.1. 자동 등록 - @ComponentScan</a></li>
        <li><a href="#32-수동-등록---configuration-bean">3.2. 수동 등록 - @Configuration, @Bean</a></li>
        <li><a href="#33-bean-충돌">3.3. Bean 충돌</a></li>
      </ul>
    </li>
    <li><a href="#4-의존관계-설정">4. 의존관계 설정</a>
      <ul>
        <li><a href="#41-의존관계-주입">4.1. 의존관계 주입</a></li>
        <li><a href="#42-생성자-주입">4.2. 생성자 주입</a></li>
        <li><a href="#43-requiredargsconstructor">4.3. @RequiredArgsConstructor</a></li>
      </ul>
    </li>
    <li><a href="#5-bean-선택-충돌-해결">5. Bean 선택 충돌 해결</a>
      <ul>
        <li><a href="#51-primary">5.1. @Primary</a></li>
        <li><a href="#52-qualifier">5.2. @Qualifier</a></li>
      </ul>
    </li>
    <li><a href="#6-singleton-pattern">6. Singleton Pattern</a>
      <ul>
        <li><a href="#61-singleton-개요">6.1. Singleton 개요</a></li>
        <li><a href="#62-spring의-singleton-bean">6.2. Spring의 Singleton Bean</a></li>
        <li><a href="#63-stateful-bean-주의">6.3. Stateful Bean 주의</a></li>
      </ul>
    </li>
    <li><a href="#7-validation">7. Validation</a>
      <ul>
        <li><a href="#71-bindingresult">7.1. BindingResult</a></li>
        <li><a href="#72-modelattribute-vs-requestbody">7.2. @ModelAttribute vs @RequestBody</a></li>
        <li><a href="#73-bean-validation">7.3. Bean Validation</a></li>
        <li><a href="#74-field-error">7.4. Field Error</a></li>
        <li><a href="#75-validator">7.5. Validator</a></li>
        <li><a href="#76-error-message">7.6. Error Message</a></li>
        <li><a href="#77-object-error">7.7. Object Error</a></li>
        <li><a href="#78-bean-validation의-충돌">7.8. Bean Validation의 충돌</a></li>
        <li><a href="#79-groups">7.9. groups</a></li>
        <li><a href="#710-groups-vs-dto-분리">7.10. groups vs DTO 분리</a></li>
      </ul>
    </li>
    <li><a href="#8-solid-원칙">8. SOLID 원칙</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><hr>
<h2 id="1-spring-container--bean">1. Spring Container &amp; Bean<a hidden class="anchor" aria-hidden="true" href="#1-spring-container--bean">#</a></h2>
<h3 id="11-spring-container">1.1. Spring Container<a hidden class="anchor" aria-hidden="true" href="#11-spring-container">#</a></h3>
<p>Spring 애플리케이션에서 객체(Bean)를 생성, 관리, 소멸하는 역할을 담당함.</p>
<ul>
<li>설정 파일이나 Annotation을 읽어 Bean을 생성하고 주입하는 과정을 컨트롤함.</li>
<li>Java에서는 개발자가 객체를 직접 생성하지만, Spring에서는 Container가 관리함.</li>
</ul>
<p><strong>Spring Container의 역할</strong></p>
<ul>
<li>Bean 생성, 관리, 의존성 주입을 담당함.</li>
<li>객체 간 결합도를 낮추어 OCP, DIP 원칙을 지킬 수 있음.</li>
</ul>
<p><strong>Spring Container의 종류</strong></p>
<ul>
<li>BeanFactory: Spring Container의 최상위 인터페이스</li>
<li>ApplicationContext: BeanFactory를 확장하여 다양한 기능 제공 (국제화, 환경변수, 이벤트, 리소스 조회 등)</li>
<li>실무에서는 ApplicationContext를 주로 사용함 → 보통 이것을 Spring Container라고 부름</li>
</ul>
<h3 id="12-spring-bean">1.2. Spring Bean<a hidden class="anchor" aria-hidden="true" href="#12-spring-bean">#</a></h3>
<p>Spring Container가 관리하는 객체를 의미함.</p>
<ul>
<li>일반 Java 객체에 Spring이 관리 권한을 부여하면 Bean이 됨.</li>
</ul>
<p><strong>Spring Bean의 특징</strong></p>
<ol>
<li>Container에 의해 생성되고 관리됨</li>
<li>기본적으로 Singleton</li>
<li>DI를 통해 다른 Bean과 의존관계를 가질 수 있음</li>
<li>생명주기(생성 → 초기화 → 사용 → 소멸)를 가짐</li>
</ol>
<p><strong>Bean 등록 방법</strong></p>
<ul>
<li>XML 방식 (과거)</li>
<li>Java Annotation (@Component, @Service 등)</li>
<li>Java 설정 파일 (@Configuration + @Bean)</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// Annotation 방식 예시</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyService</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Configuration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">AppConfig</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Bean</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">MyService</span><span class="w"> </span><span class="nf">myService</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MyService</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="2-객체-제어-원리-ioc--di">2. 객체 제어 원리 (IOC / DI)<a hidden class="anchor" aria-hidden="true" href="#2-객체-제어-원리-ioc--di">#</a></h2>
<h3 id="21-ioc-inversion-of-control">2.1. IOC (Inversion of Control)<a hidden class="anchor" aria-hidden="true" href="#21-ioc-inversion-of-control">#</a></h3>
<p>객체의 생성과 관리를 Spring Container가 담당하는 개념</p>
<ul>
<li>제어의 주체가 개발자에서 컨테이너로 바뀜</li>
<li>요리를 원하는 사람(개발자)이 직접 요리하지 않고, 요리사(Container)가 대신 요리해주는 개념</li>
</ul>
<h3 id="22-di-dependency-injection">2.2. DI (Dependency Injection)<a hidden class="anchor" aria-hidden="true" href="#22-di-dependency-injection">#</a></h3>
<p>Container가 객체 간의 의존성을 자동으로 주입해주는 개념</p>
<ul>
<li>개발자는 구현체를 직접 생성하지 않고, 인터페이스만 의존함</li>
<li>Spring이 객체 생성 → 주입까지 알아서 해줌</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyServiceImpl</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">MyService</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">MyRepository</span><span class="w"> </span><span class="n">myRepository</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Autowired</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">MyServiceImpl</span><span class="p">(</span><span class="n">MyRepository</span><span class="w"> </span><span class="n">myRepository</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">myRepository</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myRepository</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>DI 방식: 생성자 주입, Setter 주입, 필드 주입 등이 있음</li>
<li>필드 주입은 테스트 어려움, 순환 참조 발생 가능성으로 인해 실무에서는 권장되지 않음</li>
</ul>
<hr>
<h2 id="3-bean-등록-방식">3. Bean 등록 방식<a hidden class="anchor" aria-hidden="true" href="#3-bean-등록-방식">#</a></h2>
<h3 id="31-자동-등록---componentscan">3.1. 자동 등록 - @ComponentScan<a hidden class="anchor" aria-hidden="true" href="#31-자동-등록---componentscan">#</a></h3>
<p>지정된 패키지에서 @Component, @Service, @Repository, @Controller 등을 찾아 자동 등록함</p>
<ul>
<li>이 어노테이션들은 모두 @Component를 메타 어노테이션으로 포함하고 있음</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@ComponentScan</span><span class="p">(</span><span class="n">basePackages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;com.example&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">AppConfig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>스캔 범위는 보통 애플리케이션의 루트 패키지부터 시작함</li>
<li>Spring Boot의 @SpringBootApplication은 @ComponentScan 포함</li>
</ul>
<h3 id="32-수동-등록---configuration-bean">3.2. 수동 등록 - @Configuration, @Bean<a hidden class="anchor" aria-hidden="true" href="#32-수동-등록---configuration-bean">#</a></h3>
<p>개발자가 명시적으로 Java 설정 파일에 Bean 등록</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">AppConfig</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Bean</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">MyService</span><span class="w"> </span><span class="nf">myService</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MyServiceImpl</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="33-bean-충돌">3.3. Bean 충돌<a hidden class="anchor" aria-hidden="true" href="#33-bean-충돌">#</a></h3>
<ul>
<li>자동 vs 자동: 같은 이름의 Bean이 여러 개 존재하면 충돌 발생 → 예외 발생</li>
<li>자동 vs 수동: 수동 등록이 자동 등록을 오버라이드함</li>
<li>Spring Boot에서는 기본적으로 충돌 시 오류 발생</li>
</ul>
<p>application.properties에서 설정 가능:</p>
<pre tabindex="0"><code>spring.main.allow-bean-definition-overriding=true
</code></pre><hr>
<h2 id="4-의존관계-설정">4. 의존관계 설정<a hidden class="anchor" aria-hidden="true" href="#4-의존관계-설정">#</a></h2>
<h3 id="41-의존관계-주입">4.1. 의존관계 주입<a hidden class="anchor" aria-hidden="true" href="#41-의존관계-주입">#</a></h3>
<p>@Autowired로 객체의 의존성을 주입받음</p>
<ul>
<li>생성자 주입 (권장), Setter 주입, 필드 주입</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyApp</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">MyService</span><span class="w"> </span><span class="n">myService</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Autowired</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">MyApp</span><span class="p">(</span><span class="n">MyService</span><span class="w"> </span><span class="n">myService</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">myService</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myService</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="42-생성자-주입">4.2. 생성자 주입<a hidden class="anchor" aria-hidden="true" href="#42-생성자-주입">#</a></h3>
<ul>
<li>불변성 보장, 테스트 용이성, 실수 방지</li>
<li>생성자가 하나면 @Autowired 생략 가능</li>
<li>final 필드에만 사용 가능</li>
</ul>
<h3 id="43-requiredargsconstructor">4.3. @RequiredArgsConstructor<a hidden class="anchor" aria-hidden="true" href="#43-requiredargsconstructor">#</a></h3>
<p>Lombok이 final 필드를 기반으로 생성자 자동 생성해주는 Annotation</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RequiredArgsConstructor</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyApp</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">MyService</span><span class="w"> </span><span class="n">myService</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="5-bean-선택-충돌-해결">5. Bean 선택 충돌 해결<a hidden class="anchor" aria-hidden="true" href="#5-bean-선택-충돌-해결">#</a></h2>
<h3 id="51-primary">5.1. @Primary<a hidden class="anchor" aria-hidden="true" href="#51-primary">#</a></h3>
<p>같은 타입의 Bean이 여러 개일 때 우선순위 부여</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Primary</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyServiceImplV1</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">MyService</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="52-qualifier">5.2. @Qualifier<a hidden class="anchor" aria-hidden="true" href="#52-qualifier">#</a></h3>
<p>구분자 이름을 명시적으로 지정해 특정 Bean을 선택함</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Autowired</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="nf">MyApp</span><span class="p">(</span><span class="nd">@Qualifier</span><span class="p">(</span><span class="s">&#34;firstService&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">MyService</span><span class="w"> </span><span class="n">myService</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">myService</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myService</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="6-singleton-pattern">6. Singleton Pattern<a hidden class="anchor" aria-hidden="true" href="#6-singleton-pattern">#</a></h2>
<h3 id="61-singleton-개요">6.1. Singleton 개요<a hidden class="anchor" aria-hidden="true" href="#61-singleton-개요">#</a></h3>
<p>인스턴스를 하나만 생성하여 공유하는 디자인 패턴</p>
<ul>
<li>메모리 절약, 동일 객체 사용</li>
</ul>
<h3 id="62-spring의-singleton-bean">6.2. Spring의 Singleton Bean<a hidden class="anchor" aria-hidden="true" href="#62-spring의-singleton-bean">#</a></h3>
<ul>
<li>Spring Bean은 기본적으로 Singleton</li>
<li>수동 Singleton 구현 방식의 복잡함과 단점들을 Spring이 해결</li>
</ul>
<h3 id="63-stateful-bean-주의">6.3. Stateful Bean 주의<a hidden class="anchor" aria-hidden="true" href="#63-stateful-bean-주의">#</a></h3>
<p>Bean은 무상태(stateless)로 설계해야 함</p>
<ul>
<li>상태를 가진 Bean은 동시성 문제 유발 가능</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">StatefulSingleton</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ 상태를 가지면 안됨</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="7-validation">7. Validation<a hidden class="anchor" aria-hidden="true" href="#7-validation">#</a></h2>
<h3 id="71-bindingresult">7.1. BindingResult<a hidden class="anchor" aria-hidden="true" href="#71-bindingresult">#</a></h3>
<p>검증 오류 정보를 보관하는 객체. Controller에서 유효성 검증 결과를 확인할 수 있음.</p>
<ul>
<li><code>@ModelAttribute</code> 바로 뒤에 위치해야 함</li>
<li>필드 오류가 있어도 컨트롤러 호출 가능</li>
<li>오류 정보는 <code>bindingResult.getAllErrors()</code>로 확인</li>
</ul>
<h3 id="72-modelattribute-vs-requestbody">7.2. @ModelAttribute vs @RequestBody<a hidden class="anchor" aria-hidden="true" href="#72-modelattribute-vs-requestbody">#</a></h3>
<p>요청 데이터를 바인딩하는 방식의 차이</p>
<ul>
<li><code>@ModelAttribute</code>: 필드 단위 바인딩, 일부 실패해도 컨트롤러 호출 가능</li>
<li><code>@RequestBody</code>: JSON 전체 파싱, 실패 시 컨트롤러 호출 불가 (BindingResult로 에러 처리 X)</li>
<li><code>BindingResult</code> 활용하여 JSON 오류 응답 처리 가능</li>
</ul>
<h3 id="73-bean-validation">7.3. Bean Validation<a hidden class="anchor" aria-hidden="true" href="#73-bean-validation">#</a></h3>
<p>필드의 유효성을 Annotation으로 검증하는 표준 방식</p>
<ul>
<li><code>@NotBlank</code>, <code>@NotNull</code>, <code>@Range</code> 등 사용</li>
<li><code>@Valid</code>, <code>@Validated</code>와 함께 사용</li>
<li><code>spring-boot-starter-validation</code> 의존성 필요</li>
</ul>
<h3 id="74-field-error">7.4. Field Error<a hidden class="anchor" aria-hidden="true" href="#74-field-error">#</a></h3>
<p>개별 필드의 검증 오류 정보</p>
<ul>
<li><code>bindingResult.getFieldError()</code> 등으로 확인 가능</li>
<li><code>@ModelAttribute</code> 사용 시 부분 바인딩 가능</li>
</ul>
<h3 id="75-validator">7.5. Validator<a hidden class="anchor" aria-hidden="true" href="#75-validator">#</a></h3>
<p>검증 로직을 수행하는 객체</p>
<ul>
<li><code>LocalValidatorFactoryBean</code>이 글로벌 Validator로 자동 등록</li>
<li>타입 변환 실패한 필드는 Bean Validation 적용되지 않음</li>
</ul>
<h3 id="76-error-message">7.6. Error Message<a hidden class="anchor" aria-hidden="true" href="#76-error-message">#</a></h3>
<p>에러 메시지는 기본 메시지 또는 커스터마이징 가능</p>
<ul>
<li><code>@NotBlank(message = &quot;메시지&quot;)</code> 직접 설정</li>
<li>MessageSource 활용으로 다국어 지원</li>
<li>Spring의 <code>DefaultMessageCodesResolver</code>로 메시지 코드 생성</li>
</ul>
<h3 id="77-object-error">7.7. Object Error<a hidden class="anchor" aria-hidden="true" href="#77-object-error">#</a></h3>
<p>객체 간 관계 또는 전체 검증 오류</p>
<ul>
<li><code>@ScriptAssert</code> 가능하나, 자바 코드 방식 권장</li>
<li>예: 총합(price * count) 검증 → <code>bindingResult.reject()</code> 사용</li>
</ul>
<h3 id="78-bean-validation의-충돌">7.8. Bean Validation의 충돌<a hidden class="anchor" aria-hidden="true" href="#78-bean-validation의-충돌">#</a></h3>
<p>등록/수정 요청마다 유효성 요구가 다를 때 발생</p>
<ul>
<li>하나의 DTO로 처리 시 상황별 제약 충돌 가능</li>
</ul>
<h3 id="79-groups">7.9. groups<a hidden class="anchor" aria-hidden="true" href="#79-groups">#</a></h3>
<p>상황별로 다른 유효성 검증을 적용할 때 사용</p>
<ul>
<li>그룹 인터페이스 정의 후, <code>@Validated(Group.class)</code> 사용</li>
<li>Annotation에 <code>groups = {}</code> 지정</li>
</ul>
<h3 id="710-groups-vs-dto-분리">7.10. groups vs DTO 분리<a hidden class="anchor" aria-hidden="true" href="#710-groups-vs-dto-분리">#</a></h3>
<p>실무에서는 DTO를 분리하는 방식 선호</p>
<ul>
<li>그룹 방식은 복잡하고 유지보수 어려움</li>
<li>어떤 필드가 어떤 상황에서 검증되는지 한눈에 파악하기 어려움</li>
<li><code>SaveRequestDto</code>, <code>UpdateRequestDto</code>로 역할 분리</li>
</ul>
<hr>
<h2 id="8-solid-원칙">8. SOLID 원칙<a hidden class="anchor" aria-hidden="true" href="#8-solid-원칙">#</a></h2>
<ol>
<li><strong>SRP(단일 책임 원칙)</strong>: 하나의 클래스는 하나의 책임만 가져야 한다.</li>
<li><strong>OCP(개방 폐쇄 원칙)</strong>: 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.</li>
<li><strong>LSP(리스코프 치환 원칙)</strong>: 자식 클래스는 부모 클래스를 대체할 수 있어야 한다.</li>
<li><strong>ISP(인터페이스 분리 원칙)</strong>: 작은 인터페이스 여러 개가 큰 범용 인터페이스보다 낫다.</li>
<li><strong>DIP(의존관계 역전 원칙)</strong>: 구체적인 클래스가 아닌 추상화(인터페이스)에 의존해야 한다.</li>
</ol>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/record/2025-03-27-01/">
    <span class="title">« Prev</span>
    <br>
    <span>3진법 뒤집기</span>
  </a>
  <a class="next" href="http://localhost:1313/record/2025-03-28/">
    <span class="title">Next »</span>
    <br>
    <span>Spring 심화 2</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">withong</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = '✔';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
