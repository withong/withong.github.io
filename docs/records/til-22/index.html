<!DOCTYPE html>
<html lang="ko" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Spring 심화 1 | withong</title>
<meta name="keywords" content="">
<meta name="description" content="
1. Spring Container &amp; Bean
1.1. Spring Container
Spring 애플리케이션에서 객체(Bean)를 생성, 관리, 소멸하는 역할을 담당함.

설정 파일이나 Annotation을 읽어 Bean을 생성하고 주입하는 과정을 컨트롤함.
Java에서는 개발자가 객체를 직접 생성하지만, Spring에서는 Container가 관리함.

Spring Container의 역할

Bean 생성, 관리, 의존성 주입을 담당함.
객체 간 결합도를 낮추어 OCP, DIP 원칙을 지킬 수 있음.

Spring Container의 종류

BeanFactory: Spring Container의 최상위 인터페이스
ApplicationContext: BeanFactory를 확장하여 다양한 기능 제공 (국제화, 환경변수, 이벤트, 리소스 조회 등)
실무에서는 ApplicationContext를 주로 사용함 → 보통 이것을 Spring Container라고 부름

1.2. Spring Bean
Spring Container가 관리하는 객체를 의미함.">
<meta name="author" content="">
<link rel="canonical" href="https://withong.github.io/records/til-22/">
<link crossorigin="anonymous" href="https://withong.github.io/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://withong.github.io/icons/code.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://withong.github.io/icons/code.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://withong.github.io/icons/code.png">
<link rel="apple-touch-icon" href="https://withong.github.io/icons/zep.png">
<link rel="mask-icon" href="https://withong.github.io/icons/zep.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="https://withong.github.io/records/til-22/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://withong.github.io/records/til-22/">
  <meta property="og:site_name" content="withong">
  <meta property="og:title" content="Spring 심화 1">
  <meta property="og:description" content=" 1. Spring Container &amp; Bean 1.1. Spring Container Spring 애플리케이션에서 객체(Bean)를 생성, 관리, 소멸하는 역할을 담당함.
설정 파일이나 Annotation을 읽어 Bean을 생성하고 주입하는 과정을 컨트롤함. Java에서는 개발자가 객체를 직접 생성하지만, Spring에서는 Container가 관리함. Spring Container의 역할
Bean 생성, 관리, 의존성 주입을 담당함. 객체 간 결합도를 낮추어 OCP, DIP 원칙을 지킬 수 있음. Spring Container의 종류
BeanFactory: Spring Container의 최상위 인터페이스 ApplicationContext: BeanFactory를 확장하여 다양한 기능 제공 (국제화, 환경변수, 이벤트, 리소스 조회 등) 실무에서는 ApplicationContext를 주로 사용함 → 보통 이것을 Spring Container라고 부름 1.2. Spring Bean Spring Container가 관리하는 객체를 의미함.">
  <meta property="og:locale" content="ko">
  <meta property="og:type" content="article">
    <meta property="article:section" content="records">
    <meta property="article:published_time" content="2025-03-27T20:25:30+09:00">
    <meta property="article:modified_time" content="2025-03-27T20:25:30+09:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring 심화 1">
<meta name="twitter:description" content="
1. Spring Container &amp; Bean
1.1. Spring Container
Spring 애플리케이션에서 객체(Bean)를 생성, 관리, 소멸하는 역할을 담당함.

설정 파일이나 Annotation을 읽어 Bean을 생성하고 주입하는 과정을 컨트롤함.
Java에서는 개발자가 객체를 직접 생성하지만, Spring에서는 Container가 관리함.

Spring Container의 역할

Bean 생성, 관리, 의존성 주입을 담당함.
객체 간 결합도를 낮추어 OCP, DIP 원칙을 지킬 수 있음.

Spring Container의 종류

BeanFactory: Spring Container의 최상위 인터페이스
ApplicationContext: BeanFactory를 확장하여 다양한 기능 제공 (국제화, 환경변수, 이벤트, 리소스 조회 등)
실무에서는 ApplicationContext를 주로 사용함 → 보통 이것을 Spring Container라고 부름

1.2. Spring Bean
Spring Container가 관리하는 객체를 의미함.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Records",
      "item": "https://withong.github.io/records/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Spring 심화 1",
      "item": "https://withong.github.io/records/til-22/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Spring 심화 1",
  "name": "Spring 심화 1",
  "description": " 1. Spring Container \u0026amp; Bean 1.1. Spring Container Spring 애플리케이션에서 객체(Bean)를 생성, 관리, 소멸하는 역할을 담당함.\n설정 파일이나 Annotation을 읽어 Bean을 생성하고 주입하는 과정을 컨트롤함. Java에서는 개발자가 객체를 직접 생성하지만, Spring에서는 Container가 관리함. Spring Container의 역할\nBean 생성, 관리, 의존성 주입을 담당함. 객체 간 결합도를 낮추어 OCP, DIP 원칙을 지킬 수 있음. Spring Container의 종류\nBeanFactory: Spring Container의 최상위 인터페이스 ApplicationContext: BeanFactory를 확장하여 다양한 기능 제공 (국제화, 환경변수, 이벤트, 리소스 조회 등) 실무에서는 ApplicationContext를 주로 사용함 → 보통 이것을 Spring Container라고 부름 1.2. Spring Bean Spring Container가 관리하는 객체를 의미함.\n",
  "keywords": [
    
  ],
  "articleBody": " 1. Spring Container \u0026 Bean 1.1. Spring Container Spring 애플리케이션에서 객체(Bean)를 생성, 관리, 소멸하는 역할을 담당함.\n설정 파일이나 Annotation을 읽어 Bean을 생성하고 주입하는 과정을 컨트롤함. Java에서는 개발자가 객체를 직접 생성하지만, Spring에서는 Container가 관리함. Spring Container의 역할\nBean 생성, 관리, 의존성 주입을 담당함. 객체 간 결합도를 낮추어 OCP, DIP 원칙을 지킬 수 있음. Spring Container의 종류\nBeanFactory: Spring Container의 최상위 인터페이스 ApplicationContext: BeanFactory를 확장하여 다양한 기능 제공 (국제화, 환경변수, 이벤트, 리소스 조회 등) 실무에서는 ApplicationContext를 주로 사용함 → 보통 이것을 Spring Container라고 부름 1.2. Spring Bean Spring Container가 관리하는 객체를 의미함.\n일반 Java 객체에 Spring이 관리 권한을 부여하면 Bean이 됨. Spring Bean의 특징\nContainer에 의해 생성되고 관리됨 기본적으로 Singleton DI를 통해 다른 Bean과 의존관계를 가질 수 있음 생명주기(생성 → 초기화 → 사용 → 소멸)를 가짐 Bean 등록 방법\nXML 방식 (과거) Java Annotation (@Component, @Service 등) Java 설정 파일 (@Configuration + @Bean) // Annotation 방식 예시 @Component public class MyService { } @Configuration public class AppConfig { @Bean public MyService myService() { return new MyService(); } } 2. 객체 제어 원리 (IOC / DI) 2.1. IOC (Inversion of Control) 객체의 생성과 관리를 Spring Container가 담당하는 개념\n제어의 주체가 개발자에서 컨테이너로 바뀜 요리를 원하는 사람(개발자)이 직접 요리하지 않고, 요리사(Container)가 대신 요리해주는 개념 2.2. DI (Dependency Injection) Container가 객체 간의 의존성을 자동으로 주입해주는 개념\n개발자는 구현체를 직접 생성하지 않고, 인터페이스만 의존함 Spring이 객체 생성 → 주입까지 알아서 해줌 @Service public class MyServiceImpl implements MyService { private final MyRepository myRepository; @Autowired public MyServiceImpl(MyRepository myRepository) { this.myRepository = myRepository; } } DI 방식: 생성자 주입, Setter 주입, 필드 주입 등이 있음 필드 주입은 테스트 어려움, 순환 참조 발생 가능성으로 인해 실무에서는 권장되지 않음 3. Bean 등록 방식 3.1. 자동 등록 - @ComponentScan 지정된 패키지에서 @Component, @Service, @Repository, @Controller 등을 찾아 자동 등록함\n이 어노테이션들은 모두 @Component를 메타 어노테이션으로 포함하고 있음 @ComponentScan(basePackages = \"com.example\") public class AppConfig { } 스캔 범위는 보통 애플리케이션의 루트 패키지부터 시작함 Spring Boot의 @SpringBootApplication은 @ComponentScan 포함 3.2. 수동 등록 - @Configuration, @Bean 개발자가 명시적으로 Java 설정 파일에 Bean 등록\n@Configuration public class AppConfig { @Bean public MyService myService() { return new MyServiceImpl(); } } 3.3. Bean 충돌 자동 vs 자동: 같은 이름의 Bean이 여러 개 존재하면 충돌 발생 → 예외 발생 자동 vs 수동: 수동 등록이 자동 등록을 오버라이드함 Spring Boot에서는 기본적으로 충돌 시 오류 발생 application.properties에서 설정 가능:\nspring.main.allow-bean-definition-overriding=true 4. 의존관계 설정 4.1. 의존관계 주입 @Autowired로 객체의 의존성을 주입받음\n생성자 주입 (권장), Setter 주입, 필드 주입 @Component public class MyApp { private final MyService myService; @Autowired public MyApp(MyService myService) { this.myService = myService; } } 4.2. 생성자 주입 불변성 보장, 테스트 용이성, 실수 방지 생성자가 하나면 @Autowired 생략 가능 final 필드에만 사용 가능 4.3. @RequiredArgsConstructor Lombok이 final 필드를 기반으로 생성자 자동 생성해주는 Annotation\n@RequiredArgsConstructor @Component public class MyApp { private final MyService myService; } 5. Bean 선택 충돌 해결 5.1. @Primary 같은 타입의 Bean이 여러 개일 때 우선순위 부여\n@Component @Primary public class MyServiceImplV1 implements MyService { } 5.2. @Qualifier 구분자 이름을 명시적으로 지정해 특정 Bean을 선택함\n@Autowired public MyApp(@Qualifier(\"firstService\") MyService myService) { this.myService = myService; } 6. Singleton Pattern 6.1. Singleton 개요 인스턴스를 하나만 생성하여 공유하는 디자인 패턴\n메모리 절약, 동일 객체 사용 6.2. Spring의 Singleton Bean Spring Bean은 기본적으로 Singleton 수동 Singleton 구현 방식의 복잡함과 단점들을 Spring이 해결 6.3. Stateful Bean 주의 Bean은 무상태(stateless)로 설계해야 함\n상태를 가진 Bean은 동시성 문제 유발 가능 public class StatefulSingleton { private int value; // ❌ 상태를 가지면 안됨 } 7. Validation 7.1. BindingResult 검증 오류 정보를 보관하는 객체. Controller에서 유효성 검증 결과를 확인할 수 있음.\n@ModelAttribute 바로 뒤에 위치해야 함 필드 오류가 있어도 컨트롤러 호출 가능 오류 정보는 bindingResult.getAllErrors()로 확인 7.2. @ModelAttribute vs @RequestBody 요청 데이터를 바인딩하는 방식의 차이\n@ModelAttribute: 필드 단위 바인딩, 일부 실패해도 컨트롤러 호출 가능 @RequestBody: JSON 전체 파싱, 실패 시 컨트롤러 호출 불가 (BindingResult로 에러 처리 X) BindingResult 활용하여 JSON 오류 응답 처리 가능 7.3. Bean Validation 필드의 유효성을 Annotation으로 검증하는 표준 방식\n@NotBlank, @NotNull, @Range 등 사용 @Valid, @Validated와 함께 사용 spring-boot-starter-validation 의존성 필요 7.4. Field Error 개별 필드의 검증 오류 정보\nbindingResult.getFieldError() 등으로 확인 가능 @ModelAttribute 사용 시 부분 바인딩 가능 7.5. Validator 검증 로직을 수행하는 객체\nLocalValidatorFactoryBean이 글로벌 Validator로 자동 등록 타입 변환 실패한 필드는 Bean Validation 적용되지 않음 7.6. Error Message 에러 메시지는 기본 메시지 또는 커스터마이징 가능\n@NotBlank(message = \"메시지\") 직접 설정 MessageSource 활용으로 다국어 지원 Spring의 DefaultMessageCodesResolver로 메시지 코드 생성 7.7. Object Error 객체 간 관계 또는 전체 검증 오류\n@ScriptAssert 가능하나, 자바 코드 방식 권장 예: 총합(price * count) 검증 → bindingResult.reject() 사용 7.8. Bean Validation의 충돌 등록/수정 요청마다 유효성 요구가 다를 때 발생\n하나의 DTO로 처리 시 상황별 제약 충돌 가능 7.9. groups 상황별로 다른 유효성 검증을 적용할 때 사용\n그룹 인터페이스 정의 후, @Validated(Group.class) 사용 Annotation에 groups = {} 지정 7.10. groups vs DTO 분리 실무에서는 DTO를 분리하는 방식 선호\n그룹 방식은 복잡하고 유지보수 어려움 어떤 필드가 어떤 상황에서 검증되는지 한눈에 파악하기 어려움 SaveRequestDto, UpdateRequestDto로 역할 분리 8. SOLID 원칙 SRP(단일 책임 원칙): 하나의 클래스는 하나의 책임만 가져야 한다. OCP(개방 폐쇄 원칙): 확장에는 열려 있고, 수정에는 닫혀 있어야 한다. LSP(리스코프 치환 원칙): 자식 클래스는 부모 클래스를 대체할 수 있어야 한다. ISP(인터페이스 분리 원칙): 작은 인터페이스 여러 개가 큰 범용 인터페이스보다 낫다. DIP(의존관계 역전 원칙): 구체적인 클래스가 아닌 추상화(인터페이스)에 의존해야 한다. ",
  "wordCount" : "852",
  "inLanguage": "ko",
  "datePublished": "2025-03-27T20:25:30+09:00",
  "dateModified": "2025-03-27T20:25:30+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://withong.github.io/records/til-22/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "withong",
    "logo": {
      "@type": "ImageObject",
      "url": "https://withong.github.io/icons/code.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://withong.github.io/" accesskey="h" title="withong (Alt + H)">withong</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://withong.github.io/log/" title="Log">
                    <span>Log</span>
                </a>
            </li>
            <li>
                <a href="https://withong.github.io/topic/" title="Topic">
                    <span>Topic</span>
                </a>
            </li>
            <li>
                <a href="https://withong.github.io/tag/" title="Tag">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://withong.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://withong.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://withong.github.io/records/">Records</a></div>
    <h1 class="post-title entry-hint-parent">
      Spring 심화 1
    </h1>
    <div class="post-meta"><span title='2025-03-27 20:25:30 +0900 KST'>2025년 3월 27일</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">목차</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-spring-container--bean">1. Spring Container &amp; Bean</a>
      <ul>
        <li><a href="#11-spring-container">1.1. Spring Container</a></li>
        <li><a href="#12-spring-bean">1.2. Spring Bean</a></li>
      </ul>
    </li>
    <li><a href="#2-객체-제어-원리-ioc--di">2. 객체 제어 원리 (IOC / DI)</a>
      <ul>
        <li><a href="#21-ioc-inversion-of-control">2.1. IOC (Inversion of Control)</a></li>
        <li><a href="#22-di-dependency-injection">2.2. DI (Dependency Injection)</a></li>
      </ul>
    </li>
    <li><a href="#3-bean-등록-방식">3. Bean 등록 방식</a>
      <ul>
        <li><a href="#31-자동-등록---componentscan">3.1. 자동 등록 - @ComponentScan</a></li>
        <li><a href="#32-수동-등록---configuration-bean">3.2. 수동 등록 - @Configuration, @Bean</a></li>
        <li><a href="#33-bean-충돌">3.3. Bean 충돌</a></li>
      </ul>
    </li>
    <li><a href="#4-의존관계-설정">4. 의존관계 설정</a>
      <ul>
        <li><a href="#41-의존관계-주입">4.1. 의존관계 주입</a></li>
        <li><a href="#42-생성자-주입">4.2. 생성자 주입</a></li>
        <li><a href="#43-requiredargsconstructor">4.3. @RequiredArgsConstructor</a></li>
      </ul>
    </li>
    <li><a href="#5-bean-선택-충돌-해결">5. Bean 선택 충돌 해결</a>
      <ul>
        <li><a href="#51-primary">5.1. @Primary</a></li>
        <li><a href="#52-qualifier">5.2. @Qualifier</a></li>
      </ul>
    </li>
    <li><a href="#6-singleton-pattern">6. Singleton Pattern</a>
      <ul>
        <li><a href="#61-singleton-개요">6.1. Singleton 개요</a></li>
        <li><a href="#62-spring의-singleton-bean">6.2. Spring의 Singleton Bean</a></li>
        <li><a href="#63-stateful-bean-주의">6.3. Stateful Bean 주의</a></li>
      </ul>
    </li>
    <li><a href="#7-validation">7. Validation</a>
      <ul>
        <li><a href="#71-bindingresult">7.1. BindingResult</a></li>
        <li><a href="#72-modelattribute-vs-requestbody">7.2. @ModelAttribute vs @RequestBody</a></li>
        <li><a href="#73-bean-validation">7.3. Bean Validation</a></li>
        <li><a href="#74-field-error">7.4. Field Error</a></li>
        <li><a href="#75-validator">7.5. Validator</a></li>
        <li><a href="#76-error-message">7.6. Error Message</a></li>
        <li><a href="#77-object-error">7.7. Object Error</a></li>
        <li><a href="#78-bean-validation의-충돌">7.8. Bean Validation의 충돌</a></li>
        <li><a href="#79-groups">7.9. groups</a></li>
        <li><a href="#710-groups-vs-dto-분리">7.10. groups vs DTO 분리</a></li>
      </ul>
    </li>
    <li><a href="#8-solid-원칙">8. SOLID 원칙</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><hr>
<h2 id="1-spring-container--bean">1. Spring Container &amp; Bean<a hidden class="anchor" aria-hidden="true" href="#1-spring-container--bean">#</a></h2>
<h3 id="11-spring-container">1.1. Spring Container<a hidden class="anchor" aria-hidden="true" href="#11-spring-container">#</a></h3>
<p>Spring 애플리케이션에서 객체(Bean)를 생성, 관리, 소멸하는 역할을 담당함.</p>
<ul>
<li>설정 파일이나 Annotation을 읽어 Bean을 생성하고 주입하는 과정을 컨트롤함.</li>
<li>Java에서는 개발자가 객체를 직접 생성하지만, Spring에서는 Container가 관리함.</li>
</ul>
<p><strong>Spring Container의 역할</strong></p>
<ul>
<li>Bean 생성, 관리, 의존성 주입을 담당함.</li>
<li>객체 간 결합도를 낮추어 OCP, DIP 원칙을 지킬 수 있음.</li>
</ul>
<p><strong>Spring Container의 종류</strong></p>
<ul>
<li>BeanFactory: Spring Container의 최상위 인터페이스</li>
<li>ApplicationContext: BeanFactory를 확장하여 다양한 기능 제공 (국제화, 환경변수, 이벤트, 리소스 조회 등)</li>
<li>실무에서는 ApplicationContext를 주로 사용함 → 보통 이것을 Spring Container라고 부름</li>
</ul>
<h3 id="12-spring-bean">1.2. Spring Bean<a hidden class="anchor" aria-hidden="true" href="#12-spring-bean">#</a></h3>
<p>Spring Container가 관리하는 객체를 의미함.</p>
<ul>
<li>일반 Java 객체에 Spring이 관리 권한을 부여하면 Bean이 됨.</li>
</ul>
<p><strong>Spring Bean의 특징</strong></p>
<ol>
<li>Container에 의해 생성되고 관리됨</li>
<li>기본적으로 Singleton</li>
<li>DI를 통해 다른 Bean과 의존관계를 가질 수 있음</li>
<li>생명주기(생성 → 초기화 → 사용 → 소멸)를 가짐</li>
</ol>
<p><strong>Bean 등록 방법</strong></p>
<ul>
<li>XML 방식 (과거)</li>
<li>Java Annotation (@Component, @Service 등)</li>
<li>Java 설정 파일 (@Configuration + @Bean)</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// Annotation 방식 예시</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyService</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Configuration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">AppConfig</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Bean</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">MyService</span><span class="w"> </span><span class="nf">myService</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MyService</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="2-객체-제어-원리-ioc--di">2. 객체 제어 원리 (IOC / DI)<a hidden class="anchor" aria-hidden="true" href="#2-객체-제어-원리-ioc--di">#</a></h2>
<h3 id="21-ioc-inversion-of-control">2.1. IOC (Inversion of Control)<a hidden class="anchor" aria-hidden="true" href="#21-ioc-inversion-of-control">#</a></h3>
<p>객체의 생성과 관리를 Spring Container가 담당하는 개념</p>
<ul>
<li>제어의 주체가 개발자에서 컨테이너로 바뀜</li>
<li>요리를 원하는 사람(개발자)이 직접 요리하지 않고, 요리사(Container)가 대신 요리해주는 개념</li>
</ul>
<h3 id="22-di-dependency-injection">2.2. DI (Dependency Injection)<a hidden class="anchor" aria-hidden="true" href="#22-di-dependency-injection">#</a></h3>
<p>Container가 객체 간의 의존성을 자동으로 주입해주는 개념</p>
<ul>
<li>개발자는 구현체를 직접 생성하지 않고, 인터페이스만 의존함</li>
<li>Spring이 객체 생성 → 주입까지 알아서 해줌</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyServiceImpl</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">MyService</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">MyRepository</span><span class="w"> </span><span class="n">myRepository</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Autowired</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">MyServiceImpl</span><span class="p">(</span><span class="n">MyRepository</span><span class="w"> </span><span class="n">myRepository</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">myRepository</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myRepository</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>DI 방식: 생성자 주입, Setter 주입, 필드 주입 등이 있음</li>
<li>필드 주입은 테스트 어려움, 순환 참조 발생 가능성으로 인해 실무에서는 권장되지 않음</li>
</ul>
<hr>
<h2 id="3-bean-등록-방식">3. Bean 등록 방식<a hidden class="anchor" aria-hidden="true" href="#3-bean-등록-방식">#</a></h2>
<h3 id="31-자동-등록---componentscan">3.1. 자동 등록 - @ComponentScan<a hidden class="anchor" aria-hidden="true" href="#31-자동-등록---componentscan">#</a></h3>
<p>지정된 패키지에서 @Component, @Service, @Repository, @Controller 등을 찾아 자동 등록함</p>
<ul>
<li>이 어노테이션들은 모두 @Component를 메타 어노테이션으로 포함하고 있음</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@ComponentScan</span><span class="p">(</span><span class="n">basePackages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;com.example&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">AppConfig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>스캔 범위는 보통 애플리케이션의 루트 패키지부터 시작함</li>
<li>Spring Boot의 @SpringBootApplication은 @ComponentScan 포함</li>
</ul>
<h3 id="32-수동-등록---configuration-bean">3.2. 수동 등록 - @Configuration, @Bean<a hidden class="anchor" aria-hidden="true" href="#32-수동-등록---configuration-bean">#</a></h3>
<p>개발자가 명시적으로 Java 설정 파일에 Bean 등록</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">AppConfig</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Bean</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">MyService</span><span class="w"> </span><span class="nf">myService</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MyServiceImpl</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="33-bean-충돌">3.3. Bean 충돌<a hidden class="anchor" aria-hidden="true" href="#33-bean-충돌">#</a></h3>
<ul>
<li>자동 vs 자동: 같은 이름의 Bean이 여러 개 존재하면 충돌 발생 → 예외 발생</li>
<li>자동 vs 수동: 수동 등록이 자동 등록을 오버라이드함</li>
<li>Spring Boot에서는 기본적으로 충돌 시 오류 발생</li>
</ul>
<p>application.properties에서 설정 가능:</p>
<pre tabindex="0"><code>spring.main.allow-bean-definition-overriding=true
</code></pre><hr>
<h2 id="4-의존관계-설정">4. 의존관계 설정<a hidden class="anchor" aria-hidden="true" href="#4-의존관계-설정">#</a></h2>
<h3 id="41-의존관계-주입">4.1. 의존관계 주입<a hidden class="anchor" aria-hidden="true" href="#41-의존관계-주입">#</a></h3>
<p>@Autowired로 객체의 의존성을 주입받음</p>
<ul>
<li>생성자 주입 (권장), Setter 주입, 필드 주입</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyApp</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">MyService</span><span class="w"> </span><span class="n">myService</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Autowired</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">MyApp</span><span class="p">(</span><span class="n">MyService</span><span class="w"> </span><span class="n">myService</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">myService</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myService</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="42-생성자-주입">4.2. 생성자 주입<a hidden class="anchor" aria-hidden="true" href="#42-생성자-주입">#</a></h3>
<ul>
<li>불변성 보장, 테스트 용이성, 실수 방지</li>
<li>생성자가 하나면 @Autowired 생략 가능</li>
<li>final 필드에만 사용 가능</li>
</ul>
<h3 id="43-requiredargsconstructor">4.3. @RequiredArgsConstructor<a hidden class="anchor" aria-hidden="true" href="#43-requiredargsconstructor">#</a></h3>
<p>Lombok이 final 필드를 기반으로 생성자 자동 생성해주는 Annotation</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RequiredArgsConstructor</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyApp</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">MyService</span><span class="w"> </span><span class="n">myService</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="5-bean-선택-충돌-해결">5. Bean 선택 충돌 해결<a hidden class="anchor" aria-hidden="true" href="#5-bean-선택-충돌-해결">#</a></h2>
<h3 id="51-primary">5.1. @Primary<a hidden class="anchor" aria-hidden="true" href="#51-primary">#</a></h3>
<p>같은 타입의 Bean이 여러 개일 때 우선순위 부여</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Primary</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyServiceImplV1</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">MyService</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="52-qualifier">5.2. @Qualifier<a hidden class="anchor" aria-hidden="true" href="#52-qualifier">#</a></h3>
<p>구분자 이름을 명시적으로 지정해 특정 Bean을 선택함</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Autowired</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="nf">MyApp</span><span class="p">(</span><span class="nd">@Qualifier</span><span class="p">(</span><span class="s">&#34;firstService&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">MyService</span><span class="w"> </span><span class="n">myService</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">myService</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myService</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="6-singleton-pattern">6. Singleton Pattern<a hidden class="anchor" aria-hidden="true" href="#6-singleton-pattern">#</a></h2>
<h3 id="61-singleton-개요">6.1. Singleton 개요<a hidden class="anchor" aria-hidden="true" href="#61-singleton-개요">#</a></h3>
<p>인스턴스를 하나만 생성하여 공유하는 디자인 패턴</p>
<ul>
<li>메모리 절약, 동일 객체 사용</li>
</ul>
<h3 id="62-spring의-singleton-bean">6.2. Spring의 Singleton Bean<a hidden class="anchor" aria-hidden="true" href="#62-spring의-singleton-bean">#</a></h3>
<ul>
<li>Spring Bean은 기본적으로 Singleton</li>
<li>수동 Singleton 구현 방식의 복잡함과 단점들을 Spring이 해결</li>
</ul>
<h3 id="63-stateful-bean-주의">6.3. Stateful Bean 주의<a hidden class="anchor" aria-hidden="true" href="#63-stateful-bean-주의">#</a></h3>
<p>Bean은 무상태(stateless)로 설계해야 함</p>
<ul>
<li>상태를 가진 Bean은 동시성 문제 유발 가능</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">StatefulSingleton</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ 상태를 가지면 안됨</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="7-validation">7. Validation<a hidden class="anchor" aria-hidden="true" href="#7-validation">#</a></h2>
<h3 id="71-bindingresult">7.1. BindingResult<a hidden class="anchor" aria-hidden="true" href="#71-bindingresult">#</a></h3>
<p>검증 오류 정보를 보관하는 객체. Controller에서 유효성 검증 결과를 확인할 수 있음.</p>
<ul>
<li><code>@ModelAttribute</code> 바로 뒤에 위치해야 함</li>
<li>필드 오류가 있어도 컨트롤러 호출 가능</li>
<li>오류 정보는 <code>bindingResult.getAllErrors()</code>로 확인</li>
</ul>
<h3 id="72-modelattribute-vs-requestbody">7.2. @ModelAttribute vs @RequestBody<a hidden class="anchor" aria-hidden="true" href="#72-modelattribute-vs-requestbody">#</a></h3>
<p>요청 데이터를 바인딩하는 방식의 차이</p>
<ul>
<li><code>@ModelAttribute</code>: 필드 단위 바인딩, 일부 실패해도 컨트롤러 호출 가능</li>
<li><code>@RequestBody</code>: JSON 전체 파싱, 실패 시 컨트롤러 호출 불가 (BindingResult로 에러 처리 X)</li>
<li><code>BindingResult</code> 활용하여 JSON 오류 응답 처리 가능</li>
</ul>
<h3 id="73-bean-validation">7.3. Bean Validation<a hidden class="anchor" aria-hidden="true" href="#73-bean-validation">#</a></h3>
<p>필드의 유효성을 Annotation으로 검증하는 표준 방식</p>
<ul>
<li><code>@NotBlank</code>, <code>@NotNull</code>, <code>@Range</code> 등 사용</li>
<li><code>@Valid</code>, <code>@Validated</code>와 함께 사용</li>
<li><code>spring-boot-starter-validation</code> 의존성 필요</li>
</ul>
<h3 id="74-field-error">7.4. Field Error<a hidden class="anchor" aria-hidden="true" href="#74-field-error">#</a></h3>
<p>개별 필드의 검증 오류 정보</p>
<ul>
<li><code>bindingResult.getFieldError()</code> 등으로 확인 가능</li>
<li><code>@ModelAttribute</code> 사용 시 부분 바인딩 가능</li>
</ul>
<h3 id="75-validator">7.5. Validator<a hidden class="anchor" aria-hidden="true" href="#75-validator">#</a></h3>
<p>검증 로직을 수행하는 객체</p>
<ul>
<li><code>LocalValidatorFactoryBean</code>이 글로벌 Validator로 자동 등록</li>
<li>타입 변환 실패한 필드는 Bean Validation 적용되지 않음</li>
</ul>
<h3 id="76-error-message">7.6. Error Message<a hidden class="anchor" aria-hidden="true" href="#76-error-message">#</a></h3>
<p>에러 메시지는 기본 메시지 또는 커스터마이징 가능</p>
<ul>
<li><code>@NotBlank(message = &quot;메시지&quot;)</code> 직접 설정</li>
<li>MessageSource 활용으로 다국어 지원</li>
<li>Spring의 <code>DefaultMessageCodesResolver</code>로 메시지 코드 생성</li>
</ul>
<h3 id="77-object-error">7.7. Object Error<a hidden class="anchor" aria-hidden="true" href="#77-object-error">#</a></h3>
<p>객체 간 관계 또는 전체 검증 오류</p>
<ul>
<li><code>@ScriptAssert</code> 가능하나, 자바 코드 방식 권장</li>
<li>예: 총합(price * count) 검증 → <code>bindingResult.reject()</code> 사용</li>
</ul>
<h3 id="78-bean-validation의-충돌">7.8. Bean Validation의 충돌<a hidden class="anchor" aria-hidden="true" href="#78-bean-validation의-충돌">#</a></h3>
<p>등록/수정 요청마다 유효성 요구가 다를 때 발생</p>
<ul>
<li>하나의 DTO로 처리 시 상황별 제약 충돌 가능</li>
</ul>
<h3 id="79-groups">7.9. groups<a hidden class="anchor" aria-hidden="true" href="#79-groups">#</a></h3>
<p>상황별로 다른 유효성 검증을 적용할 때 사용</p>
<ul>
<li>그룹 인터페이스 정의 후, <code>@Validated(Group.class)</code> 사용</li>
<li>Annotation에 <code>groups = {}</code> 지정</li>
</ul>
<h3 id="710-groups-vs-dto-분리">7.10. groups vs DTO 분리<a hidden class="anchor" aria-hidden="true" href="#710-groups-vs-dto-분리">#</a></h3>
<p>실무에서는 DTO를 분리하는 방식 선호</p>
<ul>
<li>그룹 방식은 복잡하고 유지보수 어려움</li>
<li>어떤 필드가 어떤 상황에서 검증되는지 한눈에 파악하기 어려움</li>
<li><code>SaveRequestDto</code>, <code>UpdateRequestDto</code>로 역할 분리</li>
</ul>
<hr>
<h2 id="8-solid-원칙">8. SOLID 원칙<a hidden class="anchor" aria-hidden="true" href="#8-solid-원칙">#</a></h2>
<ol>
<li><strong>SRP(단일 책임 원칙)</strong>: 하나의 클래스는 하나의 책임만 가져야 한다.</li>
<li><strong>OCP(개방 폐쇄 원칙)</strong>: 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.</li>
<li><strong>LSP(리스코프 치환 원칙)</strong>: 자식 클래스는 부모 클래스를 대체할 수 있어야 한다.</li>
<li><strong>ISP(인터페이스 분리 원칙)</strong>: 작은 인터페이스 여러 개가 큰 범용 인터페이스보다 낫다.</li>
<li><strong>DIP(의존관계 역전 원칙)</strong>: 구체적인 클래스가 아닌 추상화(인터페이스)에 의존해야 한다.</li>
</ol>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://withong.github.io/">withong</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = '✔';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
