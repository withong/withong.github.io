<!DOCTYPE html>
<html lang="ko" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Records | withong</title>
<meta name="keywords" content="">
<meta name="description" content="Today I Learned">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/records/">
<link crossorigin="anonymous" href="http://localhost:1313/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/icons/code.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/icons/code.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/icons/code.png">
<link rel="apple-touch-icon" href="http://localhost:1313/icons/zep.png">
<link rel="mask-icon" href="http://localhost:1313/icons/zep.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/records/index.xml">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/records/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="withong (Alt + H)">withong</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/log/" title="Log">
                    <span>Log</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/topic/" title="Topic">
                    <span>Topic</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tag/" title="Tag">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="http://localhost:1313/">Home</a></div>
  <h1>
    Records
  </h1>
  <div class="post-description">
    Today I Learned
  </div>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring 기초 4
    </h2>
  </header>
  <div class="entry-content">
    <p> Slf4j 인터페이스이며, Logback 같은 구현체를 사용할 수 있음.
Spring Boot는 기본적으로 Logback을 제공.
System.out.println() 대신 로깅 라이브러리를 사용.
Log Level: TRACE → DEBUG → INFO → WARN → ERROR
@Slf4j @RestController public class Slf4jController { @RequestMapping(&#34;/logging&#34;) public String logging() { String sparta = &#34;Sparta&#34;; log.info(&#34;문자 info={}&#34;, sparta); return &#34;success&#34;; } } Controller vs RestController @Controller: View 반환 (Thymeleaf, JSP 사용) @Controller public class ViewController { @RequestMapping(&#34;/view&#34;) public String example() { return &#34;sparta&#34;; // View Name 반환 } } @RestController: Data 반환 (REST API) @RestController public class ResponseController { @RequestMapping(&#34;/string&#34;) public String example() { return &#34;sparta&#34;; // HTTP Body에 Data 입력 } } Annotation @Component: Spring Bean 등록하는 역할을 수행. @Target: 애노테이션 적용 범위를 지정. @Retention: 유지 기간을 결정. (SOURCE, CLASS, RUNTIME) @Documented: 문서화 도구에 의해 문서화되도록 지정. RequestMapping 특정 URL 요청을 특정 메서드와 매핑함. 여러 요소(URL, HTTP Method 등)를 조합하여 매핑할 수 있음. Spring Boot 3.0부터 /example/ 대신 /example만 허용됨. @RestController public class RequestMappingController { @RequestMapping(value = &#34;/v1&#34;, method = RequestMethod.GET) public String exampleV1() { return &#34;this is sparta!&#34;; } @GetMapping(value = &#34;/v2&#34;) public String exampleV2() { return &#34;this is sparta!&#34;; } } PathVariable URL 값을 파라미터로 받아오는 방식. @GetMapping(&#34;/{postId}&#34;) public String pathVariable(@PathVariable Long postId) { return &#34;Post ID: &#34; &#43; postId; } @GetMapping(&#34;/{postId}/comments/{commentId}&#34;) public String pathVariableMulti(@PathVariable Long postId, @PathVariable Long commentId) { return &#34;Post ID: &#34; &#43; postId &#43; &#34;, Comment ID: &#34; &#43; commentId; } 특정 파라미터 매핑 Query Parameter 매핑 @GetMapping(value = &#34;/users&#34;, params = &#34;gender=man&#34;) public String params() { return &#34;params API 호출됨&#34;; } Header 매핑 @PostMapping(value = &#34;/users&#34;, headers = &#34;Content-Type=application/json&#34;) public String headers() { return &#34;headers API 호출됨&#34;; } MediaType 매핑 @PostMapping(value = &#34;/users&#34;, consumes = MediaType.APPLICATION_JSON_VALUE) public String consumes() { return &#34;consumes API 호출됨&#34;; } produces 속성을 이용해 특정 응답 타입을 지정할 수 있음. Spring이 지원하는 Parameter 요청 헤더 조회 @Slf4j @RestController public class RequestHeaderController { @GetMapping(&#34;/request/headers&#34;) public String headers(@RequestHeader(&#34;host&#34;) String host) { log.info(&#34;host={}&#34;, host); return &#34;success&#34;; } } MultiValueMap 여러 개의 값을 받을 때 사용 MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;(); map.add(&#34;key1&#34;, &#34;value1&#34;); map.add(&#34;key1&#34;, &#34;value2&#34;); </p>
  </div>
  <footer class="entry-footer"><span title='2025-03-19 21:54:12 +0900 KST'>2025년 3월 19일</span></footer>
  <a class="entry-link" aria-label="post link to Spring 기초 4" href="http://localhost:1313/records/til-18/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring 기초 3
    </h2>
  </header>
  <div class="entry-content">
    <p> 1. MVC 패턴 Template Engine (템플릿 엔진) 동적인 웹 페이지를 생성하는 도구 HTML과 데이터를 결합해 서버에서 페이지를 렌더링함 대표적인 템플릿 엔진 Thymeleaf → Spring과 통합이 잘 되어 가장 많이 사용됨 JSP (Java Server Pages) → 예전에는 많이 사용했으나 현재는 거의 사용되지 않음 FreeMarker, Velocity, Mustache → 특정 환경에서 사용됨 과거에는 Java 코드로 직접 HTML을 생성했으나, 유지보수가 어려워서 HTML에 필요한 부분만 Java 코드로 처리하도록 발전함
MVC 패턴 개요 원래 Servlet과 JSP만으로 웹 개발을 했으나, 비즈니스 로직과 UI가 한 파일에 섞이면서 유지보수가 어려워짐 MVC (Model-View-Controller) 패턴은 역할을 분리하여 코드의 유지보수를 쉽게 하기 위해 등장함 MVC 패턴 구조 컴포넌트 설명 Model 데이터를 저장하고 처리하는 역할 (비즈니스 로직) View 사용자에게 보여주는 UI (HTML, 템플릿 엔진) Controller 사용자의 요청을 받아 Model과 View를 연결 View가 변경되어도 Model(비즈니스 로직)에 영향을 주지 않도록 분리 Model이 변경되어도 View를 수정할 필요가 없음 MVC 패턴의 문제점 중복 코드 발생 dispatcher.forward(request, response) 호출이 중복됨 View의 경로 (/WEB-INF/views/...jsp)가 코드 곳곳에 하드코딩되어 변경이 어렵다 공통 기능이 많아질수록 Controller의 역할이 커짐 로깅, 인증, 인가 등의 기능이 모든 Controller에 중복 작성됨 → 프론트 컨트롤러 패턴
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-18 18:00:16 +0900 KST'>2025년 3월 18일</span></footer>
  <a class="entry-link" aria-label="post link to Spring 기초 3" href="http://localhost:1313/records/til-17/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring 기초 2
    </h2>
  </header>
  <div class="entry-content">
    <p> 1. 프레임워크와 라이브러리 프레임워크 (Framework) 소프트웨어 개발을 간편하게 만들기 위한 개발 환경. 일정한 틀(Frame) 안에서 개발해야 하며, 개발의 일관성을 제공함. 장점: 코드의 일관성, 보안 강화, 테스트 환경 제공, 커뮤니티 지원. 단점: 학습 곡선이 높음, 새로운 버전과의 호환성 문제 발생 가능, 구조 변경 어려움. 라이브러리 (Library) 특정 기능을 수행하는 코드의 모음. 개발자가 필요할 때 가져다 사용 가능. 장점: 개발 생산성 증가, 안정성이 높은 코드 활용 가능. 단점: 업데이트 또는 지원 중단 시 문제 발생, 호환성 이슈. 2. Annotation 코드에 메타데이터를 추가하는 기능으로, 컴파일러나 런타임에서 특정 동작을 트리거함.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-18 17:32:05 +0900 KST'>2025년 3월 18일</span></footer>
  <a class="entry-link" aria-label="post link to Spring 기초 2" href="http://localhost:1313/records/til-16/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring 기초 1
    </h2>
  </header>
  <div class="entry-content">
    <p> 네트워크 인터넷(Internet) TCP/IP 기반으로 동작하는 글로벌 네트워크. 데이터 전송을 위해 유선(해저 케이블) 및 무선(위성 통신) 활용. 인터넷 프로토콜(IP, Internet Protocol) 네트워크 내에서 기기를 식별하는 주소 체계. 예시: 192.168.0.1 IP 방식의 문제점 애플리케이션 구분 불가능. 비연결성: 수신 대상의 상태를 고려하지 않고 전송. 비신뢰성: 패킷 손실 및 순서 뒤섞임 가능. TCP와 UDP TCP(Transmission Control Protocol) 신뢰성 있는 데이터 전송 (3-Way Handshake 방식). 패킷 순서 보장 및 오류 검출 가능. UDP(User Datagram Protocol) 빠른 전송 속도를 우선시 (비신뢰성 전송). 실시간 스트리밍, 온라인 게임 등에 사용. PORT 같은 IP에서 여러 프로세스를 구분하는 번호. 주요 포트 번호: HTTP(80), HTTPS(443), FTP(21), SSH(22). Web DNS(Domain Name System) 도메인과 IP 주소를 매핑하는 시스템. 사람이 이해하기 쉬운 도메인(google.com)을 IP 주소로 변환. URI(Uniform Resource Identifier) 인터넷 자원의 고유 식별자. URL(Uniform Resource Locator) 리소스의 위치를 나타내는 형식 (https://spartacodingclub.kr/). 브라우저에 URL을 입력하면 사용자가 브라우저에 URL을 입력. DNS 조회를 통해 도메인에 해당하는 IP 주소 확인. 웹 브라우저가 HTTP 요청을 생성. 요청 패킷이 서버로 전송. 서버에서 HTTP 요청을 처리 후 응답 생성. 응답 패킷이 클라이언트로 전송. 브라우저가 응답 데이터를 렌더링하여 화면 표시. 용어 모음 프로그래밍 명명규칙(Casing) snake_case: Python, DB 테이블에서 사용 (user_name). camelCase: Java, JavaScript에서 변수 및 메서드 이름에 사용 (userName). PascalCase: 클래스 및 객체 이름에 사용 (UserName). kebab-case: URL 및 CSS에서 사용 (user-name). JSON(JavaScript Object Notation) 클라이언트-서버 간 데이터 교환을 위한 경량 데이터 포맷. XML 대비 가독성이 뛰어나고 용량이 작음. Scale Up, Scale Out Scale Up: 단일 서버의 성능 향상 (CPU, RAM 증가). Scale Out: 여러 대의 서버 확장 (부하 분산). Stateful vs Stateless Stateful: 클라이언트의 상태를 유지해야 하는 서비스. Stateless: 서버가 클라이언트 상태를 저장하지 않음 (확장성 우수). Connection vs Connectionless Connection: 지속적 연결 유지 (HTTP/1.0). Connectionless: 필요할 때만 연결 (HTTP/1.1, HTTP/2). HTTP HTTP(HyperText Transfer Protocol) 인터넷 상에서 클라이언트와 서버 간 데이터를 교환하는 프로토콜. HTTP 특징 Stateless(무상태): 클라이언트의 상태를 저장하지 않음. Connectionless(비연결): 요청-응답 후 연결을 끊음. HTTP Message 구조 Request (요청) Start Line: HTTP Method, URL, HTTP Version. Header: 추가적인 요청 정보 (예: Content-Type). Body: 요청 데이터 포함 (POST 요청 등). Response (응답) Status Code: 요청의 처리 결과 (200 OK, 404 Not Found 등). Header: 응답 메타데이터. Body: 응답 데이터. HTTP Method와 상태 코드 HTTP Method GET: 데이터 조회. POST: 데이터 생성. PUT: 데이터 전체 수정. PATCH: 데이터 일부 수정. DELETE: 데이터 삭제. HTTP 상태 코드 200 OK: 정상 응답. 201 Created: 리소스 생성 완료. 400 Bad Request: 잘못된 요청. 401 Unauthorized: 인증 필요. 404 Not Found: 리소스 없음. 500 Internal Server Error: 서버 내부 오류. HTTP Header HTTP Header의 역할 요청과 응답의 부가 정보 제공. 자주 사용하는 Header Content-Type: 데이터 형식 지정 (application/json). Authorization: 인증 정보 포함. Cache-Control: 캐시 정책 (max-age, no-cache 등). Set-Cookie: 쿠키 설정 (세션 관리). Restful API REST (Representational State Transfer) 리소스를 기반으로 한 API 설계 원칙. RESTful API 설계 예시 POST /boards → 게시글 생성. GET /boards → 게시글 목록 조회. GET /boards/{id} → 특정 게시글 조회. PUT /boards/{id} → 게시글 수정. DELETE /boards/{id} → 게시글 삭제. Web Application Web Server vs WAS(Web Application Server) Web Server: 정적 콘텐츠 제공 (예: Nginx, Apache). WAS: 동적 콘텐츠 처리 (예: Tomcat, Spring Boot). Web System 구성 프론트엔드(클라이언트) → 백엔드(WAS) → 데이터베이스(DB). Servlet Servlet Java 기반 웹 애플리케이션을 처리하는 기술. Servlet 동작 순서 클라이언트가 요청 전송. Servlet Container가 요청을 분석하여 Servlet 실행. Servlet이 요청을 처리하고 응답 생성. 응답이 클라이언트에게 전달됨. Thread Thread 하나의 프로세스 내에서 실행되는 작업 단위. Multi-Thread 여러 작업을 동시에 실행하는 기술 (서버 성능 향상 가능). SSR(Server Side Rendering) vs CSR(Client Side Rendering) SSR: 서버에서 HTML을 생성하여 클라이언트로 전송 (초기 로딩 속도 빠름). CSR: 클라이언트에서 JavaScript를 이용해 동적으로 렌더링 (SPA에서 주로 사용). </p>
  </div>
  <footer class="entry-footer"><span title='2025-03-17 22:00:03 +0900 KST'>2025년 3월 17일</span></footer>
  <a class="entry-link" aria-label="post link to Spring 기초 1" href="http://localhost:1313/records/til-15/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">키오스크 회고
    </h2>
  </header>
  <div class="entry-content">
    <p> 코드의 주요 기능 CartItem 클래스를 도입해 장바구니 아이템을 관리. Discount Enum을 사용해 다양한 할인 유형 적용 가능. Kiosk에서 직접 사용자 입력을 처리하고 메뉴 탐색, 장바구니 관리 등을 수행. Main에서 Kiosk를 실행해 전체 기능을 제어. 분석 Cart와 CartItem을 활용해 객체지향적으로 장바구니를 관리. Discount Enum을 통해 생일, 리뷰 작성 등 다양한 할인 적용 가능. 코드 구조 및 객체지향 설계 Kiosk 클래스가 너무 많은 기능을 포함하고 있어 SRP(단일 책임 원칙)를 지키지 못하는 부분이 있다. UI 출력과 비즈니스 로직이 혼재되어 있어 유지보수성이 낮다. 코드 스타일 및 가독성 Kiosk에서 너무 많은 로직을 처리하여 일부 메서드가 길어지고 복잡해질 가능성이 있음. 예외 처리가 부족하여, 예상치 못한 입력이 들어왔을 때 프로그램이 멈출 가능성이 있음. 코드 내 중복이 일부 존재하며, 이를 줄이면 가독성이 더 좋아질 수 있음. 실행 흐름 Main에서 Kiosk를 초기화하고 start() 실행. 사용자의 입력을 받아 메뉴 탐색, 장바구니 관리 진행. 주문 시 할인 정보를 입력받아 Discount Enum을 활용해 적용. 결제 후 장바구니를 비움. 분석 Kiosk에서 거의 모든 것을 관리하기 때문에 실행 흐름이 길어질수록 복잡해질 가능성이 있음. 기능별로 적절히 분리하면 코드의 유지보수성과 확장성이 더 좋아질 수 있음. 개선할 점 Kiosk 클래스의 역할을 분리해 KioskService 같은 클래스를 만들어야 함. UI 출력과 비즈니스 로직을 분리하여 코드의 가독성과 유지보수성을 높여야 함. 예외 처리가 부족하므로 IllegalArgumentException 등을 적극 활용해야 함. 중복된 코드가 일부 존재하므로 메서드로 분리하여 코드의 일관성을 높일 필요가 있음. 사용자의 입력을 검증하는 로직을 별도로 분리하여 입력 오류를 방지해야 함. 🗨️ by GPT
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-14 19:14:24 +0900 KST'>2025년 3월 14일</span></footer>
  <a class="entry-link" aria-label="post link to 키오스크 회고" href="http://localhost:1313/records/til-14/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/records/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/records/page/3/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">withong</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
