<!DOCTYPE html>
<html lang="ko" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[내일배움캠프] Spring 기초 1 | withong</title>
<meta name="keywords" content="">
<meta name="description" content="
네트워크(Network)
인터넷(Internet)
전 세계의 컴퓨터들이 연결된 거대한 네트워크
인터넷의 핵심 요소:

ISP(Internet Service Provider, 인터넷 서비스 제공자)

ISP를 통해 네트워크를 사용할 수 있음.


라우터(Router)

여러 개의 네트워크를 연결해주는 장치.
데이터를 목적지까지 전달하는 역할을 함.


서버(Server) &amp; 클라이언트(Client)

서버: 요청을 처리하고 응답을 주는 역할.
클라이언트: 요청을 보내고 응답을 받는 역할.



인터넷 프로토콜 IP(Internet Protocol)
인터넷에서 데이터를 전송하는 규칙

데이터를 목적지까지 전달하기 위해 경로(Route)를 설정 함.
각 컴퓨터에 고유한 주소(IP Address)를 할당 함.
패킷(Packet)이라는 작은 단위로 데이터를 나누어 전송함.
IP 자체만으로는 데이터의 신뢰성을 보장하지 않음.
패킷이 순서대로 도착하거나 손실되지 않는다는 보장은 TCP 같은 상위 프로토콜에서 처리함.

IP 방식의 문제점

비연결성

IP는 패킷을 목적지까지 보내지만, 제대로 도착했는지 확인하지 않음.
데이터를 순서대로 보장하지 않음.


신뢰성 부족

패킷이 손실될 수 있음.
데이터가 중간에 유실될 경우 재전송이 필요하지만, IP 자체는 이를 처리하지 않음.


패킷 분실 가능성

네트워크가 혼잡하면 패킷이 사라질 수 있음.



TCP(Transmission Control Protocol)
서버와 클라이언트 간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜.">
<meta name="author" content="">
<link rel="canonical" href="https://withong.github.io/camp/day-20/">
<link crossorigin="anonymous" href="https://withong.github.io/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://withong.github.io/icons/code.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://withong.github.io/icons/code.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://withong.github.io/icons/code.png">
<link rel="apple-touch-icon" href="https://withong.github.io/icons/zep.png">
<link rel="mask-icon" href="https://withong.github.io/icons/zep.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="https://withong.github.io/camp/day-20/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://withong.github.io/camp/day-20/">
  <meta property="og:site_name" content="withong">
  <meta property="og:title" content="[내일배움캠프] Spring 기초 1">
  <meta property="og:description" content=" 네트워크(Network) 인터넷(Internet) 전 세계의 컴퓨터들이 연결된 거대한 네트워크
인터넷의 핵심 요소: ISP(Internet Service Provider, 인터넷 서비스 제공자) ISP를 통해 네트워크를 사용할 수 있음. 라우터(Router) 여러 개의 네트워크를 연결해주는 장치. 데이터를 목적지까지 전달하는 역할을 함. 서버(Server) &amp; 클라이언트(Client) 서버: 요청을 처리하고 응답을 주는 역할. 클라이언트: 요청을 보내고 응답을 받는 역할. 인터넷 프로토콜 IP(Internet Protocol) 인터넷에서 데이터를 전송하는 규칙
데이터를 목적지까지 전달하기 위해 경로(Route)를 설정 함. 각 컴퓨터에 고유한 주소(IP Address)를 할당 함. 패킷(Packet)이라는 작은 단위로 데이터를 나누어 전송함. IP 자체만으로는 데이터의 신뢰성을 보장하지 않음. 패킷이 순서대로 도착하거나 손실되지 않는다는 보장은 TCP 같은 상위 프로토콜에서 처리함. IP 방식의 문제점 비연결성 IP는 패킷을 목적지까지 보내지만, 제대로 도착했는지 확인하지 않음. 데이터를 순서대로 보장하지 않음. 신뢰성 부족 패킷이 손실될 수 있음. 데이터가 중간에 유실될 경우 재전송이 필요하지만, IP 자체는 이를 처리하지 않음. 패킷 분실 가능성 네트워크가 혼잡하면 패킷이 사라질 수 있음. TCP(Transmission Control Protocol) 서버와 클라이언트 간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜.">
  <meta property="og:locale" content="ko">
  <meta property="og:type" content="article">
    <meta property="article:section" content="camp">
    <meta property="article:published_time" content="2025-03-17T21:00:00+09:00">
    <meta property="article:modified_time" content="2025-03-17T21:00:00+09:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[내일배움캠프] Spring 기초 1">
<meta name="twitter:description" content="
네트워크(Network)
인터넷(Internet)
전 세계의 컴퓨터들이 연결된 거대한 네트워크
인터넷의 핵심 요소:

ISP(Internet Service Provider, 인터넷 서비스 제공자)

ISP를 통해 네트워크를 사용할 수 있음.


라우터(Router)

여러 개의 네트워크를 연결해주는 장치.
데이터를 목적지까지 전달하는 역할을 함.


서버(Server) &amp; 클라이언트(Client)

서버: 요청을 처리하고 응답을 주는 역할.
클라이언트: 요청을 보내고 응답을 받는 역할.



인터넷 프로토콜 IP(Internet Protocol)
인터넷에서 데이터를 전송하는 규칙

데이터를 목적지까지 전달하기 위해 경로(Route)를 설정 함.
각 컴퓨터에 고유한 주소(IP Address)를 할당 함.
패킷(Packet)이라는 작은 단위로 데이터를 나누어 전송함.
IP 자체만으로는 데이터의 신뢰성을 보장하지 않음.
패킷이 순서대로 도착하거나 손실되지 않는다는 보장은 TCP 같은 상위 프로토콜에서 처리함.

IP 방식의 문제점

비연결성

IP는 패킷을 목적지까지 보내지만, 제대로 도착했는지 확인하지 않음.
데이터를 순서대로 보장하지 않음.


신뢰성 부족

패킷이 손실될 수 있음.
데이터가 중간에 유실될 경우 재전송이 필요하지만, IP 자체는 이를 처리하지 않음.


패킷 분실 가능성

네트워크가 혼잡하면 패킷이 사라질 수 있음.



TCP(Transmission Control Protocol)
서버와 클라이언트 간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Camp",
      "item": "https://withong.github.io/camp/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[내일배움캠프] Spring 기초 1",
      "item": "https://withong.github.io/camp/day-20/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[내일배움캠프] Spring 기초 1",
  "name": "[내일배움캠프] Spring 기초 1",
  "description": " 네트워크(Network) 인터넷(Internet) 전 세계의 컴퓨터들이 연결된 거대한 네트워크\n인터넷의 핵심 요소: ISP(Internet Service Provider, 인터넷 서비스 제공자) ISP를 통해 네트워크를 사용할 수 있음. 라우터(Router) 여러 개의 네트워크를 연결해주는 장치. 데이터를 목적지까지 전달하는 역할을 함. 서버(Server) \u0026amp; 클라이언트(Client) 서버: 요청을 처리하고 응답을 주는 역할. 클라이언트: 요청을 보내고 응답을 받는 역할. 인터넷 프로토콜 IP(Internet Protocol) 인터넷에서 데이터를 전송하는 규칙\n데이터를 목적지까지 전달하기 위해 경로(Route)를 설정 함. 각 컴퓨터에 고유한 주소(IP Address)를 할당 함. 패킷(Packet)이라는 작은 단위로 데이터를 나누어 전송함. IP 자체만으로는 데이터의 신뢰성을 보장하지 않음. 패킷이 순서대로 도착하거나 손실되지 않는다는 보장은 TCP 같은 상위 프로토콜에서 처리함. IP 방식의 문제점 비연결성 IP는 패킷을 목적지까지 보내지만, 제대로 도착했는지 확인하지 않음. 데이터를 순서대로 보장하지 않음. 신뢰성 부족 패킷이 손실될 수 있음. 데이터가 중간에 유실될 경우 재전송이 필요하지만, IP 자체는 이를 처리하지 않음. 패킷 분실 가능성 네트워크가 혼잡하면 패킷이 사라질 수 있음. TCP(Transmission Control Protocol) 서버와 클라이언트 간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜.\n",
  "keywords": [
    
  ],
  "articleBody": " 네트워크(Network) 인터넷(Internet) 전 세계의 컴퓨터들이 연결된 거대한 네트워크\n인터넷의 핵심 요소: ISP(Internet Service Provider, 인터넷 서비스 제공자) ISP를 통해 네트워크를 사용할 수 있음. 라우터(Router) 여러 개의 네트워크를 연결해주는 장치. 데이터를 목적지까지 전달하는 역할을 함. 서버(Server) \u0026 클라이언트(Client) 서버: 요청을 처리하고 응답을 주는 역할. 클라이언트: 요청을 보내고 응답을 받는 역할. 인터넷 프로토콜 IP(Internet Protocol) 인터넷에서 데이터를 전송하는 규칙\n데이터를 목적지까지 전달하기 위해 경로(Route)를 설정 함. 각 컴퓨터에 고유한 주소(IP Address)를 할당 함. 패킷(Packet)이라는 작은 단위로 데이터를 나누어 전송함. IP 자체만으로는 데이터의 신뢰성을 보장하지 않음. 패킷이 순서대로 도착하거나 손실되지 않는다는 보장은 TCP 같은 상위 프로토콜에서 처리함. IP 방식의 문제점 비연결성 IP는 패킷을 목적지까지 보내지만, 제대로 도착했는지 확인하지 않음. 데이터를 순서대로 보장하지 않음. 신뢰성 부족 패킷이 손실될 수 있음. 데이터가 중간에 유실될 경우 재전송이 필요하지만, IP 자체는 이를 처리하지 않음. 패킷 분실 가능성 네트워크가 혼잡하면 패킷이 사라질 수 있음. TCP(Transmission Control Protocol) 서버와 클라이언트 간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜.\n연결 지향 데이터를 보내기 전에 3-way handshake(삼중 핸드셰이크) 를 사용하여 연결을 설정함. 신뢰성 보장 데이터가 손실되지 않도록 확인 응답(ACK)을 사용하고, 손실된 패킷을 재전송함. 순서 보장 패킷이 순서대로 도착하도록 관리함. 흐름 제어 및 혼잡 제어 네트워크 속도 차이를 고려하여 데이터를 조절하고, 네트워크가 과부하 상태가 되지 않도록 조정함. UDP(User Datagram Protocol) 비연결형, 신뢰성이 없는 전송 프로토콜.\n비연결형 데이터를 보내기 전에 연결을 설정하지 않음. 빠른 전송 속도가 빠르지만, 신뢰성이 부족함. 패킷이 유실될 수 있어도 다시 전송하지 않음. 순서 보장 없음 패킷이 순서대로 도착한다는 보장이 없음. PORT 같은 IP 내에서 프로세스 구분을 하기 위해서 사용.\n자주 사용되는 PORT 0 ~ 65535 할당 가능 이미 사용되고 있는 포트 (0 ~ 1023) IANA(Internet Assigned Numbers Authority)에서 관리 사용하지 않는 것이 좋음 FTP - 20, 21 (TCP) SSH - 22 (TCP) 텔넷 - 23 (TCP) SMTP - 25 (TCP) DNS - 53 (TCP/UDP) DHCP - 67 (UDP) HTTP - 80 (TCP) HTTPS - 443 (TCP) RDP - 3389 (TCP/UDP) 관련 용어 JSON (데이터 교환 포맷) 텍스트 기반의 경량 데이터 형식\n키-값(key-value) 형태 경량 (파일 크기가 작고 빠르게 처리 가능) 언어 독립적 (Java, JavaScript, Python 등 모든 언어에서 사용 가능) 클라이언트 to 서버의 통신에 JSON을 사용 서버 to 서버의 통신에도 JSON을 사용 Scale Up, Scale Out (서버 및 네트워크 확장 관련) 서버의 성능 향상을 위한 두 가지 방법\nScale Up (수직 확장) 서버 자체의 성능을 높이는 방식 CPU, RAM, 디스크 용량을 늘려서 한 대의 서버가 더 많은 작업을 처리하게 함. Scale Out (수평 확장) 여러 개의 서버를 추가하여 부하를 분산하는 방식 로드 밸런서를 사용하여 여러 서버에 부하를 분산함. Stateful, Stateless (네트워크 세션 관리와 관련) 웹 애플리케이션이 사용자의 상태(데이터)를 어떻게 관리하는지에 대한 개념\nStateful (상태 유지) 서버가 사용자의 상태(로그인 정보, 세션 데이터 등)를 기억함. 사용자가 요청할 때마다 이전 상태를 유지함. 단점 서버가 사용자의 상태를 계속 유지해야 해서 부하 증가 여러 서버를 사용할 경우 세션 동기화 문제 발생 Stateless (상태 없음) 서버가 사용자의 상태를 저장하지 않음. 사용자의 요청은 항상 독립적인 요청으로 처리됨. 장점 같은 서버를 유지할 필요가 없음 확장성이 좋음 (Scale out 쉬움) 단점 매 요청마다 필요한 데이터를 보내야 함 Connection, Connectionless (네트워크 연결 방식) 네트워크에서 데이터를 주고받을 때 연결을 유지하는지 여부에 따른 개념\nConnection (연결 지향) 데이터를 주고받기 전에 연결을 먼저 설정하는 방식. TCP 기반, 연결을 유지하면서 데이터를 주고받음. 장점 새로운 연결 과정을 거치지 않아도 된다. 그만큼 요청에 대한 응답 속도가 빨라짐. 단점 클라이언트가 연결을 유지하지 않으면 불필요한 자원이 소모될 수 있음. Connectionless (비연결 지향) 연결을 유지하지 않고, 데이터만 보낸 후 바로 종료하는 방식. UDP 기반, 받았는지 확인하지 않음. 장점 서버 자원을 효율적으로 사용할 수 있음. 단점 추가 요청 시 새 연결(3 way handshake)로 인해 응답 시간 증가 현재는 HTTP 지속 연결로 문제를 해결 HTTP 지속연결(Persistent Connections) 여러 HTTP 요청을 하나의 TCP 연결에서 처리하여, 매 요청마다 새 연결을 맺는 비용을 줄임. 웹(Web) 기초 DNS(Domain Name System) 도메인 이름을 IP 주소로 변환하는 역할.\n동작 과정 사용자가 브라우저에 www.google.com 입력. 브라우저는 DNS 서버 에 “www.google.com의 IP 주소를 알려줘!” 라고 요청. DNS 서버가 142.250.190.78 같은 IP 주소를 반환. 브라우저가 해당 IP 주소의 서버에 접속하여 웹 페이지를 요청. URI(Uniform Resource Identifier) 웹에서 특정 자원을 식별하는 고유한 주소\n구조: https://www.example.com/products?id=1234 스킴(Scheme) : https:// (어떤 프로토콜을 사용할지 나타냄) 호스트(Host) : www.example.com (서버의 주소) 경로(Path) : /products (서버에서 자원의 위치) 쿼리(Query) : ?id=1234 (추가적인 데이터) URL(Uniform Resource Locator) 웹 상에서 특정 자원의 위치를 나타내는 주소\n구조: https://www.example.com:8080/products?id=1234#section 프로토콜 (Protocol, Scheme) : https:// 데이터를 어떻게 전송할지 정하는 규칙. http://, https://, ftp:// 등이 있음. 호스트 (Host, 도메인 이름) : www.example.com 접속할 서버의 주소. 포트 번호 (Port, 생략 가능) : 8080 서버에서 특정 서비스를 구분하는 역할. 기본 포트(생략 가능): HTTP(80), HTTPS(443). 경로 (Path) : /products 서버에서 특정 리소스가 위치한 곳. 쿼리 문자열 (Query String) : ?id=1234 추가적인 데이터를 전달하는 부분. 프래그먼트 (Fragment, 앵커 태그) : #section 페이지 내 특정 위치를 가리킴. URL과 URI의 차이점 구분 URI URL 개념 모든 리소스를 식별하는 주소 특정 리소스의 위치를 나타내는 주소 포함 관계 URL도 URI의 일부 URI에 속하는 개념 예시 mailto:user@example.com (이메일 주소) https://www.example.com (웹 주소) 모든 URL은 URI이지만, 모든 URI가 URL은 아님\nHTTP \u0026 API HTTP(HyperText Transfer Protocol) 인터넷에서 데이터를 주고받는 규칙 다양한 데이터 유형(TEXT, IMAGE, FILE, JSON 등)을 전송할 수 있음. 주요 버전 HTTP/1.1 (가장 많이 사용됨, TCP 기반) HTTP/2, HTTP/3 (성능 개선, HTTP/3는 UDP 기반) HTTP 특징 클라이언트-서버 구조 클라이언트(UI)와 서버(비즈니스 로직, 데이터 관리)를 분리하여 독립적인 발전 가능. Stateless(무상태성) 서버는 클라이언트의 상태를 저장하지 않음. 요청마다 필요한 데이터를 포함해야 함. 로그인 등 상태 유지가 필요한 경우 쿠키, 세션, 토큰 활용. Connectionless(비연결성) 요청 후 응답을 받으면 연결 종료. 성능 최적화를 위해 Persistent Connection(지속 연결) 사용. HTTP Message 구조 요청(Request)\nGET /hello HTTP/1.1\rHost: www.example.com\rUser-Agent: Mozilla/5.0\rAccept: text/html Start Line: HTTP 메서드, URL, 버전 Header: 요청 관련 추가 정보 Body: (POST, PUT 등에서 데이터 포함) 응답(Response)\nHTTP/1.1 200 OK\rContent-Type: text/html\rContent-Length: 1024\r... Start Line: HTTP 버전, 상태 코드 Header: 응답 관련 추가 정보 Body: HTML, JSON 등 실제 데이터 HTTP Method 메서드 설명 GET 데이터 조회 POST 데이터 생성 PUT 데이터 전체 수정 PATCH 데이터 일부 수정 DELETE 데이터 삭제 HTTP Method 속성 메서드 안전(Safe) 멱등(Idempotent) 캐시 가능(Cacheable) GET Ο Ο Ο POST Χ Χ Χ PUT Χ Ο Χ PATCH Χ Χ Χ DELETE Χ Ο Χ 안전(Safe)\n서버의 데이터를 변경하지 않는 메서드는 안전한 메서드. GET은 데이터를 조회하는 역할만 하므로 안전함. POST, PUT, PATCH, DELETE는 서버 데이터를 변경할 가능성이 있으므로 안전하지 않음. 멱등(Idempotent)\n동일한 요청을 여러 번 보내도 결과가 변하지 않는다면 멱등한 메서드. GET은 여러 번 호출해도 같은 데이터를 반환하므로 멱등함. PUT과 DELETE도 멱등한데, PUT은 같은 값을 덮어쓰는 방식이므로 여러 번 실행해도 결과가 같음. DELETE는 한 번 실행하든 여러 번 실행하든 동일한 리소스를 삭제하므로 멱등함. POST는 새로운 리소스를 생성하는 요청이므로 멱등하지 않음. PATCH도 일부 데이터만 수정하는 요청이므로 여러 번 실행하면 결과가 달라질 수 있어 멱등하지 않음. 캐시 가능(Cacheable)\n캐시 가능한 메서드는 브라우저나 프록시 서버가 응답을 저장하고, 동일한 요청이 오면 저장된 응답을 반환할 수 있음. GET은 캐시가 가능하며, 성능 최적화에 유용함. POST, PUT, PATCH, DELETE는 일반적으로 캐시되지 않음. 특히 POST는 호출할 때마다 새로운 리소스를 생성할 가능성이 있어 캐시되지 않음. HTTP 상태 코드 상태 코드 의미 2xx (성공) 200 OK, 201 Created, 204 No Content 3xx (리다이렉션) 301 Moved Permanently, 302 Found 4xx (클라이언트 오류) 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found 5xx (서버 오류) 500 Internal Server Error, 503 Service Unavailable HTTP API 설계 기능 HTTP 메서드 URL 게시글 생성 POST /boards 게시글 조회 GET /boards/{id} 게시글 목록 조회 GET /boards 게시글 수정 PUT or PATCH /boards/{id} 게시글 삭제 DELETE /boards/{id} 설계 원칙\n리소스 중심 (URI는 명사 사용, 동사 사용 X) 복수형 사용 (board → boards) HTTP 메서드를 활용하여 CRUD 표현 HTTP Header 요청 헤더\n헤더 설명 Host 요청 대상 서버 주소 User-Agent 클라이언트 정보 (브라우저, OS) Accept 클라이언트가 받을 수 있는 데이터 타입 응답 헤더\n헤더 설명 Content-Type 응답 데이터 타입 (application/json) Set-Cookie 쿠키 설정 Location 리다이렉트 주소 캐시 관련 헤더\n헤더 설명 Cache-Control 캐시 정책 (max-age, no-cache 등) ETag 캐시 무결성 체크 If-Modified-Since 마지막 수정 날짜 Restful API REST(Representational State Transfer)란?\nHTTP 기반의 API 설계 원칙. 리소스를 고유한 URI로 식별하고, HTTP 메서드를 활용하여 조작. RESTful API 설계 규칙 URI는 명사 사용, 동사 X ❌ /getUsers → ✅ /users 복수형 사용 ❌ /user → ✅ /users 슬래시(/) 계층 구조 표현 /users/{id}/posts CRUD 표현은 HTTP 메서드 활용 GET /users/{id} (조회) POST /users (생성) PUT /users/{id} (전체 수정) PATCH /users/{id} (일부 수정) DELETE /users/{id} (삭제) REST API 성숙도 모델 레벨 설명 Level 0 URI만 사용 (POST /operation) Level 1 리소스 기반 설계 (POST /users) Level 2 HTTP 메서드 활용 (GET /users/{id}) Level 3 HATEOAS 적용 (응답에 다음 단계 링크 포함) 웹 애플리케이션(Web Application) Web Server HTTP 기반으로 동작하며 정적 리소스(HTML, CSS, JS, 이미지 등) 를 제공. 정적 리소스: 서버에 저장된 그대로 클라이언트에 전달되는 데이터. 대표적인 웹 서버: NGINX Apache Web Server의 역할 정적 리소스 제공 HTML, CSS, JS, 이미지, 영상 파일 등의 요청 처리. 요청을 WAS로 전달 API 요청 또는 동적인 처리가 필요한 요청을 WAS로 넘김. WAS (Web Application Server) HTTP 기반으로 동작하며 웹 서버의 기능 + 애플리케이션 로직 실행 + DB와 연동. 동적 콘텐츠 처리 (예: 로그인, 게시글 조회, 회원가입 등). 대표적인 WAS: Tomcat (Spring Boot 내장) Jetty Undertow Web Server와 WAS 차이점 Web Server WAS 역할 정적 리소스 제공 동적 콘텐츠 처리 예시 HTML, CSS, JS, 이미지 DB 조회, 로직 실행 대표 서버 NGINX, Apache Tomcat, Jetty, Undertow Web System 구성 방식 WAS만 사용하는 경우 모든 요청(Web 페이지, API)을 WAS가 처리. 단점: 과부하 발생 가능성 증가. 정적 리소스 요청도 WAS가 처리하므로 비효율적 Web Server + WAS 구성 Web Server: 정적 리소스 처리. WAS: 동적 로직 처리(API 요청). 장점: 서버 부담 분산 (정적 리소스는 Web Server, 동적 처리는 WAS). 오류 페이지 제공 가능 (WAS 다운 시 Web Server가 대체 응답). Servlet Java 기반 HTTP 요청 및 응답 처리 기술. HttpServlet 클래스를 상속받아 구현. 웹 애플리케이션에서 사용자의 요청을 받고 비즈니스 로직을 실행한 후 응답을 반환. Servlet 동작 순서 클라이언트가 요청을 보냄 (localhost:8080/example). WAS가 Request, Response 객체 생성. Servlet 실행 (service() 메서드 호출). 비즈니스 로직 처리. 응답 작성 후 클라이언트에게 전송. Request, Response 객체 소멸. Servlet Container Servlet을 관리하는 환경 (WAS 내부에서 동작). 역할: Servlet 객체 생성, 초기화, 호출, 종료 관리. 싱글톤 관리 (Servlet 하나만 생성하여 공유). Multi-Thread 지원 (동시 요청 처리 가능). Thread \u0026 Multi-Thread Single Thread 방식 한 개의 요청만 처리 가능. 문제점: 하나의 요청이 지연되면 다른 요청도 모두 대기. Multi Thread 방식 (WAS 지원) 여러 개의 요청을 동시에 처리 가능. 요청마다 새로운 Thread 생성하여 처리. Thread Pool 방식 사용: 미리 Thread를 생성해두고 요청이 오면 할당. 사용 완료된 Thread는 다시 Pool로 반환. Thread Pool의 장점 Thread 생성 비용 절약 → 빠른 응답. 서버 과부하 방지 (최대 Thread 개수 제한). 동시 요청을 효율적으로 처리. SSR(Server Side Rendering) 서버에서 HTML을 생성 후 클라이언트에 전달하는 방식. Java에서는 JSP, Thymeleaf 등을 사용. 동작 흐름: 클라이언트가 HTML 요청. 서버(WAS)에서 DB 조회 후 HTML 생성. HTML을 클라이언트에게 반환. 장점: 초기 로딩 속도 빠름 (완성된 HTML 전달). SEO(Search Engine Optimization)에 유리 (검색 엔진이 HTML을 크롤링 가능). 단점: 서버 부하 증가 (모든 요청마다 HTML을 생성해야 함). 페이지 전환 시 속도 느림 (서버에서 매번 HTML 생성). CSR(Client Side Rendering) 클라이언트(브라우저)에서 HTML을 동적으로 생성하는 방식. React, Vue 같은 프레임워크 사용. 동작 흐름: 클라이언트가 빈 HTML을 요청. 브라우저가 JS를 다운로드하여 실행. JS가 HTTP API 요청 → JSON 응답 받음. JSON 데이터를 기반으로 HTML 동적 생성. 장점: 빠른 페이지 전환 (서버와 통신 없이 클라이언트에서 렌더링). 유저 인터랙션(상호작용)에 빠르게 반응. 단점: 초기 로딩 속도 느림 (JS 다운로드 후 실행 필요). SEO에 불리할 수 있음 (검색 엔진이 JS 실행을 못 하면 문제 발생). ",
  "wordCount" : "1831",
  "inLanguage": "ko",
  "datePublished": "2025-03-17T21:00:00+09:00",
  "dateModified": "2025-03-17T21:00:00+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://withong.github.io/camp/day-20/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "withong",
    "logo": {
      "@type": "ImageObject",
      "url": "https://withong.github.io/icons/code.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://withong.github.io/" accesskey="h" title="withong (Alt + H)">withong</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://withong.github.io/log/" title="Log">
                    <span>Log</span>
                </a>
            </li>
            <li>
                <a href="https://withong.github.io/topic/" title="Topic">
                    <span>Topic</span>
                </a>
            </li>
            <li>
                <a href="https://withong.github.io/tag/" title="Tag">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://withong.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://withong.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://withong.github.io/camp/">Camp</a></div>
    <h1 class="post-title entry-hint-parent">
      [내일배움캠프] Spring 기초 1
    </h1>
    <div class="post-meta"><span title='2025-03-17 21:00:00 +0900 KST'>2025년 3월 17일</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">목차</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#네트워크network">네트워크(Network)</a>
      <ul>
        <li><a href="#인터넷internet">인터넷(Internet)</a></li>
        <li><a href="#인터넷-프로토콜-ipinternet-protocol">인터넷 프로토콜 IP(Internet Protocol)</a></li>
        <li><a href="#ip-방식의-문제점">IP 방식의 문제점</a></li>
        <li><a href="#tcptransmission-control-protocol">TCP(Transmission Control Protocol)</a></li>
        <li><a href="#udpuser-datagram-protocol">UDP(User Datagram Protocol)</a></li>
        <li><a href="#port">PORT</a></li>
      </ul>
    </li>
    <li><a href="#관련-용어">관련 용어</a>
      <ul>
        <li><a href="#json-데이터-교환-포맷">JSON (데이터 교환 포맷)</a></li>
        <li><a href="#scale-up-scale-out-서버-및-네트워크-확장-관련">Scale Up, Scale Out (서버 및 네트워크 확장 관련)</a></li>
        <li><a href="#stateful-stateless-네트워크-세션-관리와-관련">Stateful, Stateless (네트워크 세션 관리와 관련)</a></li>
        <li><a href="#connection-connectionless-네트워크-연결-방식">Connection, Connectionless (네트워크 연결 방식)</a></li>
        <li><a href="#http-지속연결persistent-connections">HTTP 지속연결(Persistent Connections)</a></li>
      </ul>
    </li>
    <li><a href="#웹web-기초">웹(Web) 기초</a>
      <ul>
        <li><a href="#dnsdomain-name-system">DNS(Domain Name System)</a></li>
        <li><a href="#uriuniform-resource-identifier">URI(Uniform Resource Identifier)</a></li>
        <li><a href="#urluniform-resource-locator">URL(Uniform Resource Locator)</a></li>
        <li><a href="#url과-uri의-차이점">URL과 URI의 차이점</a></li>
      </ul>
    </li>
    <li><a href="#http--api">HTTP &amp; API</a>
      <ul>
        <li><a href="#httphypertext-transfer-protocol">HTTP(HyperText Transfer Protocol)</a></li>
        <li><a href="#http-특징">HTTP 특징</a></li>
        <li><a href="#http-message-구조">HTTP Message 구조</a></li>
        <li><a href="#http-method">HTTP Method</a></li>
        <li><a href="#http-method-속성">HTTP Method 속성</a></li>
        <li><a href="#http-상태-코드">HTTP 상태 코드</a></li>
        <li><a href="#http-api-설계">HTTP API 설계</a></li>
        <li><a href="#http-header">HTTP Header</a></li>
        <li><a href="#restful-api">Restful API</a></li>
        <li><a href="#restful-api-설계-규칙">RESTful API 설계 규칙</a></li>
        <li><a href="#rest-api-성숙도-모델">REST API 성숙도 모델</a></li>
      </ul>
    </li>
    <li><a href="#웹-애플리케이션web-application">웹 애플리케이션(Web Application)</a>
      <ul>
        <li><a href="#web-server">Web Server</a></li>
        <li><a href="#web-server의-역할">Web Server의 역할</a></li>
        <li><a href="#was-web-application-server">WAS (Web Application Server)</a></li>
        <li><a href="#web-server와-was-차이점">Web Server와 WAS 차이점</a></li>
        <li><a href="#web-system-구성-방식">Web System 구성 방식</a></li>
        <li><a href="#servlet">Servlet</a></li>
        <li><a href="#servlet-동작-순서">Servlet 동작 순서</a></li>
        <li><a href="#servlet-container">Servlet Container</a></li>
        <li><a href="#thread--multi-thread">Thread &amp; Multi-Thread</a></li>
        <li><a href="#ssrserver-side-rendering">SSR(Server Side Rendering)</a></li>
        <li><a href="#csrclient-side-rendering">CSR(Client Side Rendering)</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><hr>
<h2 id="네트워크network">네트워크(Network)<a hidden class="anchor" aria-hidden="true" href="#네트워크network">#</a></h2>
<h3 id="인터넷internet">인터넷(Internet)<a hidden class="anchor" aria-hidden="true" href="#인터넷internet">#</a></h3>
<p>전 세계의 컴퓨터들이 연결된 거대한 네트워크</p>
<h4 id="인터넷의-핵심-요소">인터넷의 핵심 요소:<a hidden class="anchor" aria-hidden="true" href="#인터넷의-핵심-요소">#</a></h4>
<ul>
<li>ISP(Internet Service Provider, 인터넷 서비스 제공자)
<ul>
<li>ISP를 통해 네트워크를 사용할 수 있음.</li>
</ul>
</li>
<li>라우터(Router)
<ul>
<li>여러 개의 네트워크를 연결해주는 장치.</li>
<li>데이터를 목적지까지 전달하는 역할을 함.</li>
</ul>
</li>
<li>서버(Server) &amp; 클라이언트(Client)
<ul>
<li>서버: 요청을 처리하고 응답을 주는 역할.</li>
<li>클라이언트: 요청을 보내고 응답을 받는 역할.</li>
</ul>
</li>
</ul>
<h3 id="인터넷-프로토콜-ipinternet-protocol">인터넷 프로토콜 IP(Internet Protocol)<a hidden class="anchor" aria-hidden="true" href="#인터넷-프로토콜-ipinternet-protocol">#</a></h3>
<p>인터넷에서 데이터를 전송하는 규칙</p>
<ul>
<li>데이터를 목적지까지 전달하기 위해 경로(Route)를 설정 함.</li>
<li>각 컴퓨터에 고유한 주소(IP Address)를 할당 함.</li>
<li>패킷(Packet)이라는 작은 단위로 데이터를 나누어 전송함.</li>
<li>IP 자체만으로는 데이터의 신뢰성을 보장하지 않음.</li>
<li>패킷이 순서대로 도착하거나 손실되지 않는다는 보장은 TCP 같은 상위 프로토콜에서 처리함.</li>
</ul>
<h3 id="ip-방식의-문제점">IP 방식의 문제점<a hidden class="anchor" aria-hidden="true" href="#ip-방식의-문제점">#</a></h3>
<ul>
<li>비연결성
<ul>
<li>IP는 패킷을 목적지까지 보내지만, 제대로 도착했는지 확인하지 않음.</li>
<li>데이터를 순서대로 보장하지 않음.</li>
</ul>
</li>
<li>신뢰성 부족
<ul>
<li>패킷이 손실될 수 있음.</li>
<li>데이터가 중간에 유실될 경우 재전송이 필요하지만, IP 자체는 이를 처리하지 않음.</li>
</ul>
</li>
<li>패킷 분실 가능성
<ul>
<li>네트워크가 혼잡하면 패킷이 사라질 수 있음.</li>
</ul>
</li>
</ul>
<h3 id="tcptransmission-control-protocol">TCP(Transmission Control Protocol)<a hidden class="anchor" aria-hidden="true" href="#tcptransmission-control-protocol">#</a></h3>
<p>서버와 클라이언트 간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜.</p>
<ul>
<li>연결 지향
<ul>
<li>데이터를 보내기 전에 3-way handshake(삼중 핸드셰이크) 를 사용하여 연결을 설정함.</li>
</ul>
</li>
<li>신뢰성 보장
<ul>
<li>데이터가 손실되지 않도록 확인 응답(ACK)을 사용하고, 손실된 패킷을 재전송함.</li>
</ul>
</li>
<li>순서 보장
<ul>
<li>패킷이 순서대로 도착하도록 관리함.</li>
</ul>
</li>
<li>흐름 제어 및 혼잡 제어
<ul>
<li>네트워크 속도 차이를 고려하여 데이터를 조절하고, 네트워크가 과부하 상태가 되지 않도록 조정함.</li>
</ul>
</li>
</ul>
<h3 id="udpuser-datagram-protocol">UDP(User Datagram Protocol)<a hidden class="anchor" aria-hidden="true" href="#udpuser-datagram-protocol">#</a></h3>
<p>비연결형, 신뢰성이 없는 전송 프로토콜.</p>
<ul>
<li>비연결형
<ul>
<li>데이터를 보내기 전에 연결을 설정하지 않음.</li>
</ul>
</li>
<li>빠른 전송
<ul>
<li>속도가 빠르지만, 신뢰성이 부족함.</li>
<li>패킷이 유실될 수 있어도 다시 전송하지 않음.</li>
</ul>
</li>
<li>순서 보장 없음
<ul>
<li>패킷이 순서대로 도착한다는 보장이 없음.</li>
</ul>
</li>
</ul>
<h3 id="port">PORT<a hidden class="anchor" aria-hidden="true" href="#port">#</a></h3>
<p>같은 IP 내에서 프로세스 구분을 하기 위해서 사용.</p>
<ul>
<li>자주 사용되는 PORT
<ol>
<li>0 ~ 65535 할당 가능</li>
<li>이미 사용되고 있는 포트 (0 ~ 1023)
<ul>
<li>IANA(Internet Assigned Numbers Authority)에서 관리</li>
<li>사용하지 않는 것이 좋음</li>
<li><code>FTP</code> - 20, 21 (TCP)</li>
<li><code>SSH</code> - 22 (TCP)</li>
<li><code>텔넷</code> - 23 (TCP)</li>
<li><code>SMTP</code> - 25 (TCP)</li>
<li><code>DNS</code> - 53 (TCP/UDP)</li>
<li><code>DHCP</code> - 67 (UDP)</li>
<li><code>HTTP</code> - 80 (TCP)</li>
<li><code>HTTPS</code> - 443 (TCP)</li>
<li><code>RDP</code> - 3389 (TCP/UDP)</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="관련-용어">관련 용어<a hidden class="anchor" aria-hidden="true" href="#관련-용어">#</a></h2>
<h3 id="json-데이터-교환-포맷">JSON (데이터 교환 포맷)<a hidden class="anchor" aria-hidden="true" href="#json-데이터-교환-포맷">#</a></h3>
<p>텍스트 기반의 경량 데이터 형식</p>
<ul>
<li>키-값(key-value) 형태</li>
<li>경량 (파일 크기가 작고 빠르게 처리 가능)</li>
<li>언어 독립적 (Java, JavaScript, Python 등 모든 언어에서 사용 가능)</li>
<li>클라이언트 to 서버의 통신에 JSON을 사용</li>
<li>서버 to 서버의 통신에도 JSON을 사용</li>
</ul>
<h3 id="scale-up-scale-out-서버-및-네트워크-확장-관련">Scale Up, Scale Out (서버 및 네트워크 확장 관련)<a hidden class="anchor" aria-hidden="true" href="#scale-up-scale-out-서버-및-네트워크-확장-관련">#</a></h3>
<p>서버의 성능 향상을 위한 두 가지 방법</p>
<ul>
<li>Scale Up (수직 확장)
<ul>
<li>서버 자체의 성능을 높이는 방식</li>
<li>CPU, RAM, 디스크 용량을 늘려서 한 대의 서버가 더 많은 작업을 처리하게 함.</li>
</ul>
</li>
<li>Scale Out (수평 확장)
<ul>
<li>여러 개의 서버를 추가하여 부하를 분산하는 방식</li>
<li>로드 밸런서를 사용하여 여러 서버에 부하를 분산함.</li>
</ul>
</li>
</ul>
<h3 id="stateful-stateless-네트워크-세션-관리와-관련">Stateful, Stateless (네트워크 세션 관리와 관련)<a hidden class="anchor" aria-hidden="true" href="#stateful-stateless-네트워크-세션-관리와-관련">#</a></h3>
<p>웹 애플리케이션이 사용자의 상태(데이터)를 어떻게 관리하는지에 대한 개념</p>
<ul>
<li>Stateful (상태 유지)
<ul>
<li>서버가 사용자의 상태(로그인 정보, 세션 데이터 등)를 기억함.</li>
<li>사용자가 요청할 때마다 이전 상태를 유지함.</li>
<li>단점
<ul>
<li>서버가 사용자의 상태를 계속 유지해야 해서 부하 증가</li>
<li>여러 서버를 사용할 경우 세션 동기화 문제 발생</li>
</ul>
</li>
</ul>
</li>
<li>Stateless (상태 없음)
<ul>
<li>서버가 사용자의 상태를 저장하지 않음.</li>
<li>사용자의 요청은 항상 독립적인 요청으로 처리됨.</li>
<li>장점
<ul>
<li>같은 서버를 유지할 필요가 없음</li>
<li>확장성이 좋음 (Scale out 쉬움)</li>
</ul>
</li>
<li>단점
<ul>
<li>매 요청마다 필요한 데이터를 보내야 함</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="connection-connectionless-네트워크-연결-방식">Connection, Connectionless (네트워크 연결 방식)<a hidden class="anchor" aria-hidden="true" href="#connection-connectionless-네트워크-연결-방식">#</a></h3>
<p>네트워크에서 데이터를 주고받을 때 연결을 유지하는지 여부에 따른 개념</p>
<ul>
<li>Connection (연결 지향)
<ul>
<li>데이터를 주고받기 전에 연결을 먼저 설정하는 방식.</li>
<li>TCP 기반, 연결을 유지하면서 데이터를 주고받음.</li>
<li>장점
<ul>
<li>새로운 연결 과정을 거치지 않아도 된다.</li>
<li>그만큼 요청에 대한 응답 속도가 빨라짐.</li>
</ul>
</li>
<li>단점
<ul>
<li>클라이언트가 연결을 유지하지 않으면 불필요한 자원이 소모될 수 있음.</li>
</ul>
</li>
</ul>
</li>
<li>Connectionless (비연결 지향)
<ul>
<li>연결을 유지하지 않고, 데이터만 보낸 후 바로 종료하는 방식.</li>
<li>UDP 기반, 받았는지 확인하지 않음.</li>
<li>장점
<ul>
<li>서버 자원을 효율적으로 사용할 수 있음.</li>
</ul>
</li>
<li>단점
<ul>
<li>추가 요청 시 새 연결(3 way handshake)로 인해 응답 시간 증가</li>
<li>현재는 HTTP 지속 연결로 문제를 해결</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="http-지속연결persistent-connections">HTTP 지속연결(Persistent Connections)<a hidden class="anchor" aria-hidden="true" href="#http-지속연결persistent-connections">#</a></h3>
<ul>
<li>여러 HTTP 요청을 하나의 TCP 연결에서 처리하여, 매 요청마다 새 연결을 맺는 비용을 줄임.</li>
</ul>
<hr>
<h2 id="웹web-기초">웹(Web) 기초<a hidden class="anchor" aria-hidden="true" href="#웹web-기초">#</a></h2>
<h3 id="dnsdomain-name-system">DNS(Domain Name System)<a hidden class="anchor" aria-hidden="true" href="#dnsdomain-name-system">#</a></h3>
<p>도메인 이름을 IP 주소로 변환하는 역할.</p>
<ul>
<li>동작 과정
<ul>
<li>사용자가 브라우저에 <a href="https://www.google.com">www.google.com</a> 입력.</li>
<li>브라우저는 DNS 서버 에 &ldquo;<a href="https://www.google.com">www.google.com</a>의 IP 주소를 알려줘!&rdquo; 라고 요청.</li>
<li>DNS 서버가 142.250.190.78 같은 IP 주소를 반환.</li>
<li>브라우저가 해당 IP 주소의 서버에 접속하여 웹 페이지를 요청.</li>
</ul>
</li>
</ul>
<h3 id="uriuniform-resource-identifier">URI(Uniform Resource Identifier)<a hidden class="anchor" aria-hidden="true" href="#uriuniform-resource-identifier">#</a></h3>
<p>웹에서 특정 자원을 식별하는 고유한 주소</p>
<h4 id="구조">구조:<a hidden class="anchor" aria-hidden="true" href="#구조">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">https://www.example.com/products?id<span class="o">=</span><span class="m">1234</span>
</span></span></code></pre></div><ul>
<li>스킴(Scheme) : https:// (어떤 프로토콜을 사용할지 나타냄)</li>
<li>호스트(Host) : <a href="https://www.example.com">www.example.com</a> (서버의 주소)</li>
<li>경로(Path) : /products (서버에서 자원의 위치)</li>
<li>쿼리(Query) : ?id=1234 (추가적인 데이터)</li>
</ul>
<h3 id="urluniform-resource-locator">URL(Uniform Resource Locator)<a hidden class="anchor" aria-hidden="true" href="#urluniform-resource-locator">#</a></h3>
<p>웹 상에서 특정 자원의 위치를 나타내는 주소</p>
<h4 id="구조-1">구조:<a hidden class="anchor" aria-hidden="true" href="#구조-1">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">https://www.example.com:8080/products?id<span class="o">=</span>1234#section
</span></span></code></pre></div><ul>
<li>프로토콜 (Protocol, Scheme) : https://
<ul>
<li>데이터를 어떻게 전송할지 정하는 규칙.</li>
<li>http://, https://, ftp:// 등이 있음.</li>
</ul>
</li>
<li>호스트 (Host, 도메인 이름) : <a href="https://www.example.com">www.example.com</a>
<ul>
<li>접속할 서버의 주소.</li>
</ul>
</li>
<li>포트 번호 (Port, 생략 가능) : 8080
<ul>
<li>서버에서 특정 서비스를 구분하는 역할.</li>
<li>기본 포트(생략 가능): HTTP(80), HTTPS(443).</li>
</ul>
</li>
<li>경로 (Path) : /products
<ul>
<li>서버에서 특정 리소스가 위치한 곳.</li>
</ul>
</li>
<li>쿼리 문자열 (Query String) : ?id=1234
<ul>
<li>추가적인 데이터를 전달하는 부분.</li>
</ul>
</li>
<li>프래그먼트 (Fragment, 앵커 태그) : #section
<ul>
<li>페이지 내 특정 위치를 가리킴.</li>
</ul>
</li>
</ul>
<h3 id="url과-uri의-차이점">URL과 URI의 차이점<a hidden class="anchor" aria-hidden="true" href="#url과-uri의-차이점">#</a></h3>
<table>
  <thead>
      <tr>
          <th>구분</th>
          <th>URI</th>
          <th>URL</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>개념</td>
          <td>모든 리소스를 식별하는 주소</td>
          <td>특정 리소스의 위치를 나타내는 주소</td>
      </tr>
      <tr>
          <td>포함 관계</td>
          <td>URL도 URI의 일부</td>
          <td>URI에 속하는 개념</td>
      </tr>
      <tr>
          <td>예시</td>
          <td><code>mailto:user@example.com</code> (이메일 주소)</td>
          <td><code>https://www.example.com</code> (웹 주소)</td>
      </tr>
  </tbody>
</table>
<p>모든 URL은 URI이지만, 모든 URI가 URL은 아님</p>
<hr>
<h2 id="http--api">HTTP &amp; API<a hidden class="anchor" aria-hidden="true" href="#http--api">#</a></h2>
<h3 id="httphypertext-transfer-protocol">HTTP(HyperText Transfer Protocol)<a hidden class="anchor" aria-hidden="true" href="#httphypertext-transfer-protocol">#</a></h3>
<ul>
<li>인터넷에서 데이터를 주고받는 규칙</li>
<li>다양한 데이터 유형(TEXT, IMAGE, FILE, JSON 등)을 전송할 수 있음.</li>
<li>주요 버전
<ul>
<li>HTTP/1.1 (가장 많이 사용됨, TCP 기반)</li>
<li>HTTP/2, HTTP/3 (성능 개선, HTTP/3는 UDP 기반)</li>
</ul>
</li>
</ul>
<h3 id="http-특징">HTTP 특징<a hidden class="anchor" aria-hidden="true" href="#http-특징">#</a></h3>
<ol>
<li>클라이언트-서버 구조
<ul>
<li>클라이언트(UI)와 서버(비즈니스 로직, 데이터 관리)를 분리하여 독립적인 발전 가능.</li>
</ul>
</li>
<li>Stateless(무상태성)
<ul>
<li>서버는 클라이언트의 상태를 저장하지 않음.</li>
<li>요청마다 필요한 데이터를 포함해야 함.</li>
<li>로그인 등 상태 유지가 필요한 경우 쿠키, 세션, 토큰 활용.</li>
</ul>
</li>
<li>Connectionless(비연결성)
<ul>
<li>요청 후 응답을 받으면 연결 종료.</li>
<li>성능 최적화를 위해 Persistent Connection(지속 연결) 사용.</li>
</ul>
</li>
</ol>
<h3 id="http-message-구조">HTTP Message 구조<a hidden class="anchor" aria-hidden="true" href="#http-message-구조">#</a></h3>
<ul>
<li>
<p>요청(Request)</p>
<pre tabindex="0"><code>GET /hello HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
</code></pre><ul>
<li>Start Line: HTTP 메서드, URL, 버전</li>
<li>Header: 요청 관련 추가 정보</li>
<li>Body: (POST, PUT 등에서 데이터 포함)</li>
</ul>
</li>
<li>
<p>응답(Response)</p>
<pre tabindex="0"><code>HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1024

&lt;html&gt;...&lt;/html&gt;
</code></pre><ul>
<li>Start Line: HTTP 버전, 상태 코드</li>
<li>Header: 응답 관련 추가 정보</li>
<li>Body: HTML, JSON 등 실제 데이터</li>
</ul>
</li>
</ul>
<h3 id="http-method">HTTP Method<a hidden class="anchor" aria-hidden="true" href="#http-method">#</a></h3>
<table>
  <thead>
      <tr>
          <th>메서드</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>GET</code></td>
          <td>데이터 조회</td>
      </tr>
      <tr>
          <td><code>POST</code></td>
          <td>데이터 생성</td>
      </tr>
      <tr>
          <td><code>PUT</code></td>
          <td>데이터 전체 수정</td>
      </tr>
      <tr>
          <td><code>PATCH</code></td>
          <td>데이터 일부 수정</td>
      </tr>
      <tr>
          <td><code>DELETE</code></td>
          <td>데이터 삭제</td>
      </tr>
  </tbody>
</table>
<h3 id="http-method-속성">HTTP Method 속성<a hidden class="anchor" aria-hidden="true" href="#http-method-속성">#</a></h3>
<table>
  <thead>
      <tr>
          <th>메서드</th>
          <th>안전(Safe)</th>
          <th>멱등(Idempotent)</th>
          <th>캐시 가능(Cacheable)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>GET</code></td>
          <td>Ο</td>
          <td>Ο</td>
          <td>Ο</td>
      </tr>
      <tr>
          <td><code>POST</code></td>
          <td>Χ</td>
          <td>Χ</td>
          <td>Χ</td>
      </tr>
      <tr>
          <td><code>PUT</code></td>
          <td>Χ</td>
          <td>Ο</td>
          <td>Χ</td>
      </tr>
      <tr>
          <td><code>PATCH</code></td>
          <td>Χ</td>
          <td>Χ</td>
          <td>Χ</td>
      </tr>
      <tr>
          <td><code>DELETE</code></td>
          <td>Χ</td>
          <td>Ο</td>
          <td>Χ</td>
      </tr>
  </tbody>
</table>
<ol>
<li>
<p>안전(Safe)</p>
<ul>
<li>서버의 데이터를 변경하지 않는 메서드는 안전한 메서드.</li>
<li><code>GET</code>은 데이터를 조회하는 역할만 하므로 안전함.</li>
<li><code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>는 서버 데이터를 변경할 가능성이 있으므로 안전하지 않음.</li>
</ul>
</li>
<li>
<p>멱등(Idempotent)</p>
<ul>
<li>동일한 요청을 여러 번 보내도 결과가 변하지 않는다면 멱등한 메서드.</li>
<li><code>GET</code>은 여러 번 호출해도 같은 데이터를 반환하므로 멱등함.</li>
<li><code>PUT</code>과 <code>DELETE</code>도 멱등한데, <code>PUT</code>은 같은 값을 덮어쓰는 방식이므로 여러 번 실행해도 결과가 같음. <code>DELETE</code>는 한 번 실행하든 여러 번 실행하든 동일한 리소스를 삭제하므로 멱등함.</li>
<li><code>POST</code>는 새로운 리소스를 생성하는 요청이므로 멱등하지 않음. <code>PATCH</code>도 일부 데이터만 수정하는 요청이므로 여러 번 실행하면 결과가 달라질 수 있어 멱등하지 않음.</li>
</ul>
</li>
<li>
<p>캐시 가능(Cacheable)</p>
<ul>
<li>캐시 가능한 메서드는 브라우저나 프록시 서버가 응답을 저장하고, 동일한 요청이 오면 저장된 응답을 반환할 수 있음.</li>
<li><code>GET</code>은 캐시가 가능하며, 성능 최적화에 유용함.</li>
<li><code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>는 일반적으로 캐시되지 않음. 특히 <code>POST</code>는 호출할 때마다 새로운 리소스를 생성할 가능성이 있어 캐시되지 않음.</li>
</ul>
</li>
</ol>
<h3 id="http-상태-코드">HTTP 상태 코드<a hidden class="anchor" aria-hidden="true" href="#http-상태-코드">#</a></h3>
<table>
  <thead>
      <tr>
          <th>상태 코드</th>
          <th>의미</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2xx (성공)</td>
          <td><code>200 OK</code>, <code>201 Created</code>, <code>204 No Content</code></td>
      </tr>
      <tr>
          <td>3xx (리다이렉션)</td>
          <td><code>301 Moved Permanently</code>, <code>302 Found</code></td>
      </tr>
      <tr>
          <td>4xx (클라이언트 오류)</td>
          <td><code>400 Bad Request</code>, <code>401 Unauthorized</code>, <code>403 Forbidden</code>, <code>404 Not Found</code></td>
      </tr>
      <tr>
          <td>5xx (서버 오류)</td>
          <td><code>500 Internal Server Error</code>, <code>503 Service Unavailable</code></td>
      </tr>
  </tbody>
</table>
<h3 id="http-api-설계">HTTP API 설계<a hidden class="anchor" aria-hidden="true" href="#http-api-설계">#</a></h3>
<table>
  <thead>
      <tr>
          <th>기능</th>
          <th>HTTP 메서드</th>
          <th>URL</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>게시글 생성</td>
          <td><code>POST</code></td>
          <td><code>/boards</code></td>
      </tr>
      <tr>
          <td>게시글 조회</td>
          <td><code>GET</code></td>
          <td><code>/boards/{id}</code></td>
      </tr>
      <tr>
          <td>게시글 목록 조회</td>
          <td><code>GET</code></td>
          <td><code>/boards</code></td>
      </tr>
      <tr>
          <td>게시글 수정</td>
          <td><code>PUT or PATCH</code></td>
          <td><code>/boards/{id}</code></td>
      </tr>
      <tr>
          <td>게시글 삭제</td>
          <td><code>DELETE</code></td>
          <td><code>/boards/{id}</code></td>
      </tr>
  </tbody>
</table>
<p>설계 원칙</p>
<ul>
<li>리소스 중심 (URI는 명사 사용, 동사 사용 X)</li>
<li>복수형 사용 (<code>board → boards</code>)</li>
<li>HTTP 메서드를 활용하여 CRUD 표현</li>
</ul>
<h3 id="http-header">HTTP Header<a hidden class="anchor" aria-hidden="true" href="#http-header">#</a></h3>
<ol>
<li>
<p>요청 헤더</p>
<table>
  <thead>
      <tr>
          <th>헤더</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>Host</code></td>
          <td>요청 대상 서버 주소</td>
      </tr>
      <tr>
          <td><code>User-Agent</code></td>
          <td>클라이언트 정보 (브라우저, OS)</td>
      </tr>
      <tr>
          <td><code>Accept</code></td>
          <td>클라이언트가 받을 수 있는 데이터 타입</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>응답 헤더</p>
<table>
  <thead>
      <tr>
          <th>헤더</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>Content-Type</code></td>
          <td>응답 데이터 타입 (<code>application/json</code>)</td>
      </tr>
      <tr>
          <td><code>Set-Cookie</code></td>
          <td>쿠키 설정</td>
      </tr>
      <tr>
          <td><code>Location</code></td>
          <td>리다이렉트 주소</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>캐시 관련 헤더</p>
<table>
  <thead>
      <tr>
          <th>헤더</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>Cache-Control</code></td>
          <td>캐시 정책 (<code>max-age</code>, <code>no-cache</code> 등)</td>
      </tr>
      <tr>
          <td><code>ETag</code></td>
          <td>캐시 무결성 체크</td>
      </tr>
      <tr>
          <td><code>If-Modified-Since</code></td>
          <td>마지막 수정 날짜</td>
      </tr>
  </tbody>
</table>
</li>
</ol>
<h3 id="restful-api">Restful API<a hidden class="anchor" aria-hidden="true" href="#restful-api">#</a></h3>
<p>REST(Representational State Transfer)란?</p>
<ul>
<li>HTTP 기반의 API 설계 원칙.</li>
<li>리소스를 고유한 URI로 식별하고, HTTP 메서드를 활용하여 조작.</li>
</ul>
<h3 id="restful-api-설계-규칙">RESTful API 설계 규칙<a hidden class="anchor" aria-hidden="true" href="#restful-api-설계-규칙">#</a></h3>
<ol>
<li>URI는 명사 사용, 동사 X
<ul>
<li>❌ <code>/getUsers</code> → ✅ <code>/users</code></li>
</ul>
</li>
<li>복수형 사용
<ul>
<li>❌ <code>/user</code> → ✅ <code>/users</code></li>
</ul>
</li>
<li>슬래시(/) 계층 구조 표현
<ul>
<li><code>/users/{id}/posts</code></li>
</ul>
</li>
<li>CRUD 표현은 HTTP 메서드 활용
<ul>
<li><code>GET /users/{id}</code> (조회)</li>
<li><code>POST /users</code> (생성)</li>
<li><code>PUT /users/{id}</code> (전체 수정)</li>
<li><code>PATCH /users/{id}</code> (일부 수정)</li>
<li><code>DELETE /users/{id}</code> (삭제)</li>
</ul>
</li>
</ol>
<h3 id="rest-api-성숙도-모델">REST API 성숙도 모델<a hidden class="anchor" aria-hidden="true" href="#rest-api-성숙도-모델">#</a></h3>
<table>
  <thead>
      <tr>
          <th>레벨</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Level 0</td>
          <td>URI만 사용 (<code>POST /operation</code>)</td>
      </tr>
      <tr>
          <td>Level 1</td>
          <td>리소스 기반 설계 (<code>POST /users</code>)</td>
      </tr>
      <tr>
          <td>Level 2</td>
          <td>HTTP 메서드 활용 (<code>GET /users/{id}</code>)</td>
      </tr>
      <tr>
          <td>Level 3</td>
          <td>HATEOAS 적용 (응답에 다음 단계 링크 포함)</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="웹-애플리케이션web-application">웹 애플리케이션(Web Application)<a hidden class="anchor" aria-hidden="true" href="#웹-애플리케이션web-application">#</a></h2>
<h3 id="web-server">Web Server<a hidden class="anchor" aria-hidden="true" href="#web-server">#</a></h3>
<ul>
<li>HTTP 기반으로 동작하며 정적 리소스(HTML, CSS, JS, 이미지 등) 를 제공.</li>
<li>정적 리소스: 서버에 저장된 그대로 클라이언트에 전달되는 데이터.</li>
<li>대표적인 웹 서버:
<ul>
<li>NGINX</li>
<li>Apache</li>
</ul>
</li>
</ul>
<h3 id="web-server의-역할">Web Server의 역할<a hidden class="anchor" aria-hidden="true" href="#web-server의-역할">#</a></h3>
<ol>
<li>정적 리소스 제공
<ul>
<li>HTML, CSS, JS, 이미지, 영상 파일 등의 요청 처리.</li>
</ul>
</li>
<li>요청을 WAS로 전달
<ul>
<li>API 요청 또는 동적인 처리가 필요한 요청을 WAS로 넘김.</li>
</ul>
</li>
</ol>
<h3 id="was-web-application-server">WAS (Web Application Server)<a hidden class="anchor" aria-hidden="true" href="#was-web-application-server">#</a></h3>
<ul>
<li>HTTP 기반으로 동작하며 웹 서버의 기능 + 애플리케이션 로직 실행 + DB와 연동.</li>
<li>동적 콘텐츠 처리 (예: 로그인, 게시글 조회, 회원가입 등).</li>
<li>대표적인 WAS:
<ul>
<li>Tomcat (Spring Boot 내장)</li>
<li>Jetty</li>
<li>Undertow</li>
</ul>
</li>
</ul>
<h3 id="web-server와-was-차이점">Web Server와 WAS 차이점<a hidden class="anchor" aria-hidden="true" href="#web-server와-was-차이점">#</a></h3>
<table>
  <thead>
      <tr>
          <th></th>
          <th>Web Server</th>
          <th>WAS</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>역할</td>
          <td>정적 리소스 제공</td>
          <td>동적 콘텐츠 처리</td>
      </tr>
      <tr>
          <td>예시</td>
          <td>HTML, CSS, JS, 이미지</td>
          <td>DB 조회, 로직 실행</td>
      </tr>
      <tr>
          <td>대표 서버</td>
          <td>NGINX, Apache</td>
          <td>Tomcat, Jetty, Undertow</td>
      </tr>
  </tbody>
</table>
<h3 id="web-system-구성-방식">Web System 구성 방식<a hidden class="anchor" aria-hidden="true" href="#web-system-구성-방식">#</a></h3>
<h4 id="was만-사용하는-경우">WAS만 사용하는 경우<a hidden class="anchor" aria-hidden="true" href="#was만-사용하는-경우">#</a></h4>
<ul>
<li>모든 요청(Web 페이지, API)을 WAS가 처리.</li>
<li>단점:
<ul>
<li>과부하 발생 가능성 증가.</li>
<li>정적 리소스 요청도 WAS가 처리하므로 비효율적</li>
</ul>
</li>
</ul>
<h4 id="web-server--was-구성">Web Server + WAS 구성<a hidden class="anchor" aria-hidden="true" href="#web-server--was-구성">#</a></h4>
<ul>
<li>Web Server: 정적 리소스 처리.</li>
<li>WAS: 동적 로직 처리(API 요청).</li>
<li>장점:
<ul>
<li>서버 부담 분산 (정적 리소스는 Web Server, 동적 처리는 WAS).</li>
<li>오류 페이지 제공 가능 (WAS 다운 시 Web Server가 대체 응답).</li>
</ul>
</li>
</ul>
<h3 id="servlet">Servlet<a hidden class="anchor" aria-hidden="true" href="#servlet">#</a></h3>
<ul>
<li>Java 기반 HTTP 요청 및 응답 처리 기술.</li>
<li><code>HttpServlet</code> 클래스를 상속받아 구현.</li>
<li>웹 애플리케이션에서 사용자의 요청을 받고 비즈니스 로직을 실행한 후 응답을 반환.</li>
</ul>
<h3 id="servlet-동작-순서">Servlet 동작 순서<a hidden class="anchor" aria-hidden="true" href="#servlet-동작-순서">#</a></h3>
<ol>
<li>클라이언트가 요청을 보냄 (<code>localhost:8080/example</code>).</li>
<li>WAS가 Request, Response 객체 생성.</li>
<li>Servlet 실행 (<code>service()</code> 메서드 호출).</li>
<li>비즈니스 로직 처리.</li>
<li>응답 작성 후 클라이언트에게 전송.</li>
<li>Request, Response 객체 소멸.</li>
</ol>
<h3 id="servlet-container">Servlet Container<a hidden class="anchor" aria-hidden="true" href="#servlet-container">#</a></h3>
<ul>
<li>Servlet을 관리하는 환경 (WAS 내부에서 동작).</li>
<li>역할:
<ul>
<li>Servlet 객체 생성, 초기화, 호출, 종료 관리.</li>
<li>싱글톤 관리 (Servlet 하나만 생성하여 공유).</li>
<li>Multi-Thread 지원 (동시 요청 처리 가능).</li>
</ul>
</li>
</ul>
<h3 id="thread--multi-thread">Thread &amp; Multi-Thread<a hidden class="anchor" aria-hidden="true" href="#thread--multi-thread">#</a></h3>
<h4 id="single-thread-방식">Single Thread 방식<a hidden class="anchor" aria-hidden="true" href="#single-thread-방식">#</a></h4>
<ul>
<li>한 개의 요청만 처리 가능.</li>
<li>문제점: 하나의 요청이 지연되면 다른 요청도 모두 대기.</li>
</ul>
<h4 id="multi-thread-방식-was-지원">Multi Thread 방식 (WAS 지원)<a hidden class="anchor" aria-hidden="true" href="#multi-thread-방식-was-지원">#</a></h4>
<ul>
<li>여러 개의 요청을 동시에 처리 가능.</li>
<li>요청마다 새로운 Thread 생성하여 처리.</li>
<li>Thread Pool 방식 사용:
<ul>
<li>미리 Thread를 생성해두고 요청이 오면 할당.</li>
<li>사용 완료된 Thread는 다시 Pool로 반환.</li>
</ul>
</li>
</ul>
<h4 id="thread-pool의-장점">Thread Pool의 장점<a hidden class="anchor" aria-hidden="true" href="#thread-pool의-장점">#</a></h4>
<ol>
<li>Thread 생성 비용 절약 → 빠른 응답.</li>
<li>서버 과부하 방지 (최대 Thread 개수 제한).</li>
<li>동시 요청을 효율적으로 처리.</li>
</ol>
<h3 id="ssrserver-side-rendering">SSR(Server Side Rendering)<a hidden class="anchor" aria-hidden="true" href="#ssrserver-side-rendering">#</a></h3>
<ul>
<li>서버에서 HTML을 생성 후 클라이언트에 전달하는 방식.</li>
<li>Java에서는 JSP, Thymeleaf 등을 사용.</li>
</ul>
<h4 id="동작-흐름">동작 흐름:<a hidden class="anchor" aria-hidden="true" href="#동작-흐름">#</a></h4>
<ol>
<li>클라이언트가 HTML 요청.</li>
<li>서버(WAS)에서 DB 조회 후 HTML 생성.</li>
<li>HTML을 클라이언트에게 반환.</li>
</ol>
<h4 id="장점">장점:<a hidden class="anchor" aria-hidden="true" href="#장점">#</a></h4>
<ol>
<li>초기 로딩 속도 빠름 (완성된 HTML 전달).</li>
<li>SEO(Search Engine Optimization)에 유리 (검색 엔진이 HTML을 크롤링 가능).</li>
</ol>
<h4 id="단점">단점:<a hidden class="anchor" aria-hidden="true" href="#단점">#</a></h4>
<ol>
<li>서버 부하 증가 (모든 요청마다 HTML을 생성해야 함).</li>
<li>페이지 전환 시 속도 느림 (서버에서 매번 HTML 생성).</li>
</ol>
<h3 id="csrclient-side-rendering">CSR(Client Side Rendering)<a hidden class="anchor" aria-hidden="true" href="#csrclient-side-rendering">#</a></h3>
<ul>
<li>클라이언트(브라우저)에서 HTML을 동적으로 생성하는 방식.</li>
<li>React, Vue 같은 프레임워크 사용.</li>
</ul>
<h4 id="동작-흐름-1">동작 흐름:<a hidden class="anchor" aria-hidden="true" href="#동작-흐름-1">#</a></h4>
<ol>
<li>클라이언트가 빈 HTML을 요청.</li>
<li>브라우저가 JS를 다운로드하여 실행.</li>
<li>JS가 HTTP API 요청 → JSON 응답 받음.</li>
<li>JSON 데이터를 기반으로 HTML 동적 생성.</li>
</ol>
<h4 id="장점-1">장점:<a hidden class="anchor" aria-hidden="true" href="#장점-1">#</a></h4>
<ol>
<li>빠른 페이지 전환 (서버와 통신 없이 클라이언트에서 렌더링).</li>
<li>유저 인터랙션(상호작용)에 빠르게 반응.</li>
</ol>
<h4 id="단점-1">단점:<a hidden class="anchor" aria-hidden="true" href="#단점-1">#</a></h4>
<ol>
<li>초기 로딩 속도 느림 (JS 다운로드 후 실행 필요).</li>
<li>SEO에 불리할 수 있음 (검색 엔진이 JS 실행을 못 하면 문제 발생).</li>
</ol>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://withong.github.io/camp/day-19/">
    <span class="title">« Prev</span>
    <br>
    <span>[내일배움캠프] 키오스크 코드 분석 및 개선 방향</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://withong.github.io/">withong</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = '✓';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
